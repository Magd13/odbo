{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function (s, family, size, color) {\n  // also allow the form font(s, {family, size, color})\n  if (Lib.isPlainObject(family)) {\n    color = family.color;\n    size = family.size;\n    family = family.family;\n  }\n  if (family) s.style('font-family', family);\n  if (size + 1) s.style('font-size', size + 'px');\n  if (color) s.call(Color.fill, color);\n};\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function (s, x, y) {\n  s.attr('x', x).attr('y', y);\n};\ndrawing.setSize = function (s, w, h) {\n  s.attr('width', w).attr('height', h);\n};\ndrawing.setRect = function (s, x, y, w, h) {\n  s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function (d, sel, xa, ya) {\n  var x = xa.c2p(d.x);\n  var y = ya.c2p(d.y);\n  if (isNumeric(x) && isNumeric(y) && sel.node()) {\n    // for multiline text this works better\n    if (sel.node().nodeName === 'text') {\n      sel.attr('x', x).attr('y', y);\n    } else {\n      sel.attr('transform', strTranslate(x, y));\n    }\n  } else {\n    return false;\n  }\n  return true;\n};\ndrawing.translatePoints = function (s, xa, ya) {\n  s.each(function (d) {\n    var sel = d3.select(this);\n    drawing.translatePoint(d, sel, xa, ya);\n  });\n};\ndrawing.hideOutsideRangePoint = function (d, sel, xa, ya, xcalendar, ycalendar) {\n  sel.attr('display', xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : 'none');\n};\ndrawing.hideOutsideRangePoints = function (traceGroups, subplot) {\n  if (!subplot._hasClipOnAxisFalse) return;\n  var xa = subplot.xaxis;\n  var ya = subplot.yaxis;\n  traceGroups.each(function (d) {\n    var trace = d[0].trace;\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n    traceGroups.selectAll(selector).each(function (d) {\n      drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n    });\n  });\n};\ndrawing.crispRound = function (gd, lineWidth, dflt) {\n  // for lines that disable antialiasing we want to\n  // make sure the width is an integer, and at least 1 if it's nonzero\n\n  if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n  // but not for static plots - these don't get antialiased anyway.\n  if (gd._context.staticPlot) return lineWidth;\n  if (lineWidth < 1) return 1;\n  return Math.round(lineWidth);\n};\ndrawing.singleLineStyle = function (d, s, lw, lc, ld) {\n  s.style('fill', 'none');\n  var line = (((d || [])[0] || {}).trace || {}).line || {};\n  var lw1 = lw || line.width || 0;\n  var dash = ld || line.dash || '';\n  Color.stroke(s, lc || line.color);\n  drawing.dashLine(s, dash, lw1);\n};\ndrawing.lineGroupStyle = function (s, lw, lc, ld) {\n  s.style('fill', 'none').each(function (d) {\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n    d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);\n  });\n};\ndrawing.dashLine = function (s, dash, lineWidth) {\n  lineWidth = +lineWidth || 0;\n  dash = drawing.dashStyle(dash, lineWidth);\n  s.style({\n    'stroke-dasharray': dash,\n    'stroke-width': lineWidth + 'px'\n  });\n};\ndrawing.dashStyle = function (dash, lineWidth) {\n  lineWidth = +lineWidth || 1;\n  var dlw = Math.max(lineWidth, 3);\n  if (dash === 'solid') dash = '';else if (dash === 'dot') dash = dlw + 'px,' + dlw + 'px';else if (dash === 'dash') dash = 3 * dlw + 'px,' + 3 * dlw + 'px';else if (dash === 'longdash') dash = 5 * dlw + 'px,' + 5 * dlw + 'px';else if (dash === 'dashdot') {\n    dash = 3 * dlw + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n  } else if (dash === 'longdashdot') {\n    dash = 5 * dlw + 'px,' + 2 * dlw + 'px,' + dlw + 'px,' + 2 * dlw + 'px';\n  }\n  // otherwise user wrote the dasharray themselves - leave it be\n\n  return dash;\n};\nfunction setFillStyle(sel, trace, gd) {\n  var markerPattern = trace.fillpattern;\n  var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n  if (patternShape) {\n    var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n    var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n    var patternFGOpacity = markerPattern.fgopacity;\n    var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n    var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n    var patternID = trace.uid;\n    drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, undefined, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n  } else if (trace.fillcolor) {\n    sel.call(Color.fill, trace.fillcolor);\n  }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function (sel, gd) {\n  var node = d3.select(sel.node());\n  var data = node.data();\n  var trace = ((data[0] || [])[0] || {}).trace || {};\n  setFillStyle(sel, trace, gd);\n};\ndrawing.fillGroupStyle = function (s, gd) {\n  s.style('stroke-width', 0).each(function (d) {\n    var shape = d3.select(this);\n    // N.B. 'd' won't be a calcdata item when\n    // fill !== 'none' on a segment-less and marker-less trace\n    if (d[0].trace) {\n      setFillStyle(shape, d[0].trace, gd);\n    }\n  });\n};\nvar SYMBOLDEFS = require('./symbol_defs');\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\nObject.keys(SYMBOLDEFS).forEach(function (k) {\n  var symDef = SYMBOLDEFS[k];\n  var n = symDef.n;\n  drawing.symbolList.push(n, String(n), k, n + 100, String(n + 100), k + '-open');\n  drawing.symbolNames[n] = k;\n  drawing.symbolFuncs[n] = symDef.f;\n  drawing.symbolBackOffs[n] = symDef.backoff || 0;\n  if (symDef.needLine) {\n    drawing.symbolNeedLines[n] = true;\n  }\n  if (symDef.noDot) {\n    drawing.symbolNoDot[n] = true;\n  } else {\n    drawing.symbolList.push(n + 200, String(n + 200), k + '-dot', n + 300, String(n + 300), k + '-open-dot');\n  }\n  if (symDef.noFill) {\n    drawing.symbolNoFill[n] = true;\n  }\n});\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\ndrawing.symbolNumber = function (v) {\n  if (isNumeric(v)) {\n    v = +v;\n  } else if (typeof v === 'string') {\n    var vbase = 0;\n    if (v.indexOf('-open') > 0) {\n      vbase = 100;\n      v = v.replace('-open', '');\n    }\n    if (v.indexOf('-dot') > 0) {\n      vbase += 200;\n      v = v.replace('-dot', '');\n    }\n    v = drawing.symbolNames.indexOf(v);\n    if (v >= 0) {\n      v += vbase;\n    }\n  }\n  return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));\n};\nfunction makePointPath(symbolNumber, r, t, s) {\n  var base = symbolNumber % 100;\n  return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\nvar HORZGRADIENT = {\n  x1: 1,\n  x2: 0,\n  y1: 0,\n  y2: 0\n};\nvar VERTGRADIENT = {\n  x1: 0,\n  x2: 0,\n  y1: 1,\n  y2: 0\n};\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n  radial: {\n    node: 'radialGradient'\n  },\n  radialreversed: {\n    node: 'radialGradient',\n    reversed: true\n  },\n  horizontal: {\n    node: 'linearGradient',\n    attrs: HORZGRADIENT\n  },\n  horizontalreversed: {\n    node: 'linearGradient',\n    attrs: HORZGRADIENT,\n    reversed: true\n  },\n  vertical: {\n    node: 'linearGradient',\n    attrs: VERTGRADIENT\n  },\n  verticalreversed: {\n    node: 'linearGradient',\n    attrs: VERTGRADIENT,\n    reversed: true\n  }\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function (sel, gd, gradientID, type, colorscale, prop) {\n  var len = colorscale.length;\n  var info = gradientInfo[type];\n  var colorStops = new Array(len);\n  for (var i = 0; i < len; i++) {\n    if (info.reversed) {\n      colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n    } else {\n      colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n  var gradient = fullLayout._defs.select('.gradients').selectAll('#' + fullID).data([type + colorStops.join(';')], Lib.identity);\n  gradient.exit().remove();\n  gradient.enter().append(info.node).each(function () {\n    var el = d3.select(this);\n    if (info.attrs) el.attr(info.attrs);\n    el.attr('id', fullID);\n    var stops = el.selectAll('stop').data(colorStops);\n    stops.exit().remove();\n    stops.enter().append('stop');\n    stops.each(function (d) {\n      var tc = tinycolor(d[1]);\n      d3.select(this).attr({\n        offset: d[0] + '%',\n        'stop-color': Color.tinyRGB(tc),\n        'stop-opacity': tc.getAlpha()\n      });\n    });\n  });\n  sel.style(prop, getFullUrl(fullID, gd)).style(prop + '-opacity', null);\n  sel.classed('gradient_filled', true);\n};\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function (sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n  var isLegend = calledBy === 'legend';\n  if (mcc) {\n    if (fillmode === 'overlay') {\n      bgcolor = mcc;\n      fgcolor = Color.contrast(bgcolor);\n    } else {\n      bgcolor = undefined;\n      fgcolor = mcc;\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'p' + fullLayout._uid + '-' + patternID;\n  var width, height;\n\n  // linear interpolation\n  var linearFn = function (x, x0, x1, y0, y1) {\n    return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n  };\n  var path, linewidth, radius;\n  var patternTag;\n  var patternAttrs = {};\n  var fgC = tinycolor(fgcolor);\n  var fgRGB = Color.tinyRGB(fgC);\n  var fgAlpha = fgC.getAlpha();\n  var opacity = fgopacity * fgAlpha;\n  switch (shape) {\n    case '/':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '\\\\':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case 'x':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2 + 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '|':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '-':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '+':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height + 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '.':\n      width = size;\n      height = size;\n      if (solidity < Math.PI / 4) {\n        radius = Math.sqrt(solidity * size * size / Math.PI);\n      } else {\n        radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n      }\n      patternTag = 'circle';\n      patternAttrs = {\n        cx: width / 2,\n        cy: height / 2,\n        r: radius,\n        opacity: opacity,\n        fill: fgRGB\n      };\n      break;\n  }\n  var str = [shape || 'noSh', bgcolor || 'noBg', fgcolor || 'noFg', size, solidity].join(';');\n  var pattern = fullLayout._defs.select('.patterns').selectAll('#' + fullID).data([str], Lib.identity);\n  pattern.exit().remove();\n  pattern.enter().append('pattern').each(function () {\n    var el = d3.select(this);\n    el.attr({\n      id: fullID,\n      width: width + 'px',\n      height: height + 'px',\n      patternUnits: 'userSpaceOnUse',\n      // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n      patternTransform: isLegend ? 'scale(0.8)' : ''\n    });\n    if (bgcolor) {\n      var bgC = tinycolor(bgcolor);\n      var bgRGB = Color.tinyRGB(bgC);\n      var bgAlpha = bgC.getAlpha();\n      var rects = el.selectAll('rect').data([0]);\n      rects.exit().remove();\n      rects.enter().append('rect').attr({\n        width: width + 'px',\n        height: height + 'px',\n        fill: bgRGB,\n        'fill-opacity': bgAlpha\n      });\n    }\n    var patterns = el.selectAll(patternTag).data([0]);\n    patterns.exit().remove();\n    patterns.enter().append(patternTag).attr(patternAttrs);\n  });\n  sel.style('fill', getFullUrl(fullID, gd)).style('fill-opacity', null);\n  sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n  gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n  d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\ndrawing.initPatterns = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n  patternsGroup.selectAll('pattern').remove();\n  d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\ndrawing.getPatternAttr = function (mp, i, dflt) {\n  if (mp && Lib.isArrayOrTypedArray(mp)) {\n    return i < mp.length ? mp[i] : dflt;\n  }\n  return mp;\n};\ndrawing.pointStyle = function (s, trace, gd, pt) {\n  if (!s.size()) return;\n  var fns = drawing.makePointStyleFns(trace);\n  s.each(function (d) {\n    drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);\n  });\n};\ndrawing.singlePointStyle = function (d, sel, trace, fns, gd, pt) {\n  var marker = trace.marker;\n  var markerLine = marker.line;\n  if (pt && pt.i >= 0 && d.i === undefined) d.i = pt.i;\n  sel.style('opacity', fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === undefined ? marker.opacity : d.mo);\n  if (fns.ms2mrc) {\n    var r;\n\n    // handle multi-trace graph edit case\n    if (d.ms === 'various' || marker.size === 'various') {\n      r = 3;\n    } else {\n      r = fns.ms2mrc(d.ms);\n    }\n\n    // store the calculated size so hover can use it\n    d.mrc = r;\n    if (fns.selectedSizeFn) {\n      r = d.mrc = fns.selectedSizeFn(d);\n    }\n\n    // turn the symbol into a sanitized number\n    var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n    // save if this marker is open\n    // because that impacts how to handle colors\n    d.om = x % 200 >= 100;\n    var angle = getMarkerAngle(d, trace);\n    var standoff = getMarkerStandoff(d, trace);\n    sel.attr('d', makePointPath(x, r, angle, standoff));\n  }\n  var perPointGradient = false;\n  var fillColor, lineColor, lineWidth;\n\n  // 'so' is suspected outliers, for box plots\n  if (d.so) {\n    lineWidth = markerLine.outlierwidth;\n    lineColor = markerLine.outliercolor;\n    fillColor = marker.outliercolor;\n  } else {\n    var markerLineWidth = (markerLine || {}).width;\n    lineWidth = (d.mlw + 1 || markerLineWidth + 1 ||\n    // TODO: we need the latter for legends... can we get rid of it?\n    (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;\n    if ('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n    // weird case: array wasn't long enough to apply to every point\n    else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;else lineColor = markerLine.color;\n    if (Lib.isArrayOrTypedArray(marker.color)) {\n      fillColor = Color.defaultLine;\n      perPointGradient = true;\n    }\n    if ('mc' in d) {\n      fillColor = d.mcc = fns.markerScale(d.mc);\n    } else {\n      fillColor = marker.color || marker.colors || 'rgba(0,0,0,0)';\n    }\n    if (fns.selectedColorFn) {\n      fillColor = fns.selectedColorFn(d);\n    }\n  }\n  if (d.om) {\n    // open markers can't have zero linewidth, default to 1px,\n    // and use fill color as stroke color\n    sel.call(Color.stroke, fillColor).style({\n      'stroke-width': (lineWidth || 1) + 'px',\n      fill: 'none'\n    });\n  } else {\n    sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n    var markerGradient = marker.gradient;\n    var gradientType = d.mgt;\n    if (gradientType) perPointGradient = true;else gradientType = markerGradient && markerGradient.type;\n\n    // for legend - arrays will propagate through here, but we don't need\n    // to treat it as per-point.\n    if (Lib.isArrayOrTypedArray(gradientType)) {\n      gradientType = gradientType[0];\n      if (!gradientInfo[gradientType]) gradientType = 0;\n    }\n    var markerPattern = marker.pattern;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n    if (gradientType && gradientType !== 'none') {\n      var gradientColor = d.mgc;\n      if (gradientColor) perPointGradient = true;else gradientColor = markerGradient.color;\n      var gradientID = trace.uid;\n      if (perPointGradient) gradientID += '-' + d.i;\n      drawing.gradient(sel, gd, gradientID, gradientType, [[0, gradientColor], [1, fillColor]], 'fill');\n    } else if (patternShape) {\n      var perPointPattern = false;\n      var fgcolor = markerPattern.fgcolor;\n      if (!fgcolor && pt && pt.color) {\n        fgcolor = pt.color;\n        perPointPattern = true;\n      }\n      var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, pt && pt.color || null);\n      var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n      var patternFGOpacity = markerPattern.fgopacity;\n      var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n      var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n      perPointPattern = perPointPattern || d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.fgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);\n      var patternID = trace.uid;\n      if (perPointPattern) patternID += '-' + d.i;\n      drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, d.mcc, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n    } else {\n      Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);\n    }\n    if (lineWidth) {\n      Color.stroke(sel, lineColor);\n    }\n  }\n};\ndrawing.makePointStyleFns = function (trace) {\n  var out = {};\n  var marker = trace.marker;\n\n  // allow array marker and marker line colors to be\n  // scaled by given max and min to colorscales\n  out.markerScale = drawing.tryColorscale(marker, '');\n  out.lineScale = drawing.tryColorscale(marker, 'line');\n  if (Registry.traceIs(trace, 'symbols')) {\n    out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function () {\n      return (marker.size || 6) / 2;\n    };\n  }\n  if (trace.selectedpoints) {\n    Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n  }\n  return out;\n};\ndrawing.makeSelectedPointStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var marker = trace.marker || {};\n  var selectedMarker = selectedAttrs.marker || {};\n  var unselectedMarker = unselectedAttrs.marker || {};\n  var mo = marker.opacity;\n  var smo = selectedMarker.opacity;\n  var usmo = unselectedMarker.opacity;\n  var smoIsDefined = smo !== undefined;\n  var usmoIsDefined = usmo !== undefined;\n  if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n    out.selectedOpacityFn = function (d) {\n      var base = d.mo === undefined ? marker.opacity : d.mo;\n      if (d.selected) {\n        return smoIsDefined ? smo : base;\n      } else {\n        return usmoIsDefined ? usmo : DESELECTDIM * base;\n      }\n    };\n  }\n  var mc = marker.color;\n  var smc = selectedMarker.color;\n  var usmc = unselectedMarker.color;\n  if (smc || usmc) {\n    out.selectedColorFn = function (d) {\n      var base = d.mcc || mc;\n      if (d.selected) {\n        return smc || base;\n      } else {\n        return usmc || base;\n      }\n    };\n  }\n  var ms = marker.size;\n  var sms = selectedMarker.size;\n  var usms = unselectedMarker.size;\n  var smsIsDefined = sms !== undefined;\n  var usmsIsDefined = usms !== undefined;\n  if (Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n    out.selectedSizeFn = function (d) {\n      var base = d.mrc || ms / 2;\n      if (d.selected) {\n        return smsIsDefined ? sms / 2 : base;\n      } else {\n        return usmsIsDefined ? usms / 2 : base;\n      }\n    };\n  }\n  return out;\n};\ndrawing.makeSelectedTextStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var textFont = trace.textfont || {};\n  var selectedTextFont = selectedAttrs.textfont || {};\n  var unselectedTextFont = unselectedAttrs.textfont || {};\n  var tc = textFont.color;\n  var stc = selectedTextFont.color;\n  var utc = unselectedTextFont.color;\n  out.selectedTextColorFn = function (d) {\n    var base = d.tc || tc;\n    if (d.selected) {\n      return stc || base;\n    } else {\n      if (utc) return utc;else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n    }\n  };\n  return out;\n};\ndrawing.selectedPointStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedPointStyleFns(trace);\n  var marker = trace.marker || {};\n  var seq = [];\n  if (fns.selectedOpacityFn) {\n    seq.push(function (pt, d) {\n      pt.style('opacity', fns.selectedOpacityFn(d));\n    });\n  }\n  if (fns.selectedColorFn) {\n    seq.push(function (pt, d) {\n      Color.fill(pt, fns.selectedColorFn(d));\n    });\n  }\n  if (fns.selectedSizeFn) {\n    seq.push(function (pt, d) {\n      var mx = d.mx || marker.symbol || 0;\n      var mrc2 = fns.selectedSizeFn(d);\n      pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n      // save for Drawing.selectedTextStyle\n      d.mrc2 = mrc2;\n    });\n  }\n  if (seq.length) {\n    s.each(function (d) {\n      var pt = d3.select(this);\n      for (var i = 0; i < seq.length; i++) {\n        seq[i](pt, d);\n      }\n    });\n  }\n};\ndrawing.tryColorscale = function (marker, prefix) {\n  var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n  if (cont) {\n    var colorArray = cont.color;\n    if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n      return Colorscale.makeColorScaleFuncFromTrace(cont);\n    }\n  }\n  return Lib.identity;\n};\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  end: -1,\n  middle: 0,\n  bottom: 1,\n  top: -1\n};\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n  var group = d3.select(s.node().parentNode);\n  var v = textPosition.indexOf('top') !== -1 ? 'top' : textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n  var h = textPosition.indexOf('left') !== -1 ? 'end' : textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n  // if markers are shown, offset a little more than\n  // the nominal marker size\n  // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n  var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n  var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n  var dx = TEXTOFFSETSIGN[h] * r;\n  var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n  // fix the overall text group position\n  s.attr('text-anchor', h);\n  if (!dontTouchParent) {\n    group.attr('transform', strTranslate(dx, dy));\n  }\n}\nfunction extracTextFontSize(d, trace) {\n  var fontSize = d.ts || trace.textfont.size;\n  return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function (s, trace, gd) {\n  if (!s.size()) return;\n  var selectedTextColorFn;\n  if (trace.selectedpoints) {\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n    selectedTextColorFn = fns.selectedTextColorFn;\n  }\n  var texttemplate = trace.texttemplate;\n  var fullLayout = gd._fullLayout;\n  s.each(function (d) {\n    var p = d3.select(this);\n    var text = texttemplate ? Lib.extractOption(d, trace, 'txt', 'texttemplate') : Lib.extractOption(d, trace, 'tx', 'text');\n    if (!text && text !== 0) {\n      p.remove();\n      return;\n    }\n    if (texttemplate) {\n      var fn = trace._module.formatLabels;\n      var labels = fn ? fn(d, trace, fullLayout) : {};\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, d.i);\n      var meta = trace._meta || {};\n      text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n    }\n    var pos = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;\n    p.call(drawing.font, d.tf || trace.textfont.family, fontSize, fontColor).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);\n  });\n};\ndrawing.selectedTextStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedTextStyleFns(trace);\n  s.each(function (d) {\n    var tx = d3.select(this);\n    var tc = fns.selectedTextColorFn(d);\n    var tp = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    Color.fill(tx, tc);\n    var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n    textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n  });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L');\n  }\n  var path = 'M' + pts[0];\n  var tangents = [];\n  var i;\n  for (i = 1; i < pts.length - 1; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  path += 'Q' + tangents[0][0] + ' ' + pts[1];\n  for (i = 2; i < pts.length - 1; i++) {\n    path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n  }\n  path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n  return path;\n};\ndrawing.smoothclosed = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L') + 'Z';\n  }\n  var path = 'M' + pts[0];\n  var pLast = pts.length - 1;\n  var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n  var i;\n  for (i = 1; i < pLast; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  tangents.push(makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness));\n  for (i = 1; i <= pLast; i++) {\n    path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n  }\n  path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n  return path;\n};\nvar lastDrawnX, lastDrawnY;\nfunction roundEnd(pt, isY, isLastPoint) {\n  if (isLastPoint) pt = applyBackoff(pt);\n  return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\nfunction roundX(p) {\n  var v = d3.round(p, 2);\n  lastDrawnX = v;\n  return v;\n}\nfunction roundY(p) {\n  var v = d3.round(p, 2);\n  lastDrawnY = v;\n  return v;\n}\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n  var d1x = prevpt[0] - thispt[0];\n  var d1y = prevpt[1] - thispt[1];\n  var d2x = nextpt[0] - thispt[0];\n  var d2y = nextpt[1] - thispt[1];\n  var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n  var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n  var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n  var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n  var denom1 = 3 * d2a * (d1a + d2a);\n  var denom2 = 3 * d1a * (d1a + d2a);\n  return [[roundX(thispt[0] + (denom1 && numx / denom1)), roundY(thispt[1] + (denom1 && numy / denom1))], [roundX(thispt[0] - (denom2 && numx / denom2)), roundY(thispt[1] - (denom2 && numy / denom2))]];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n  hv: function (p0, p1, isLastPoint) {\n    return 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  },\n  vh: function (p0, p1, isLastPoint) {\n    return 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  hvh: function (p0, p1, isLastPoint) {\n    return 'H' + roundX((p0[0] + p1[0]) / 2) + 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  vhv: function (p0, p1, isLastPoint) {\n    return 'V' + roundY((p0[1] + p1[1]) / 2) + 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  }\n};\nvar STEPLINEAR = function (p0, p1, isLastPoint) {\n  return 'L' + roundEnd(p1, 0, isLastPoint) + ',' + roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function (shape) {\n  var onestep = STEPPATH[shape] || STEPLINEAR;\n  return function (pts) {\n    var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n    var len = pts.length;\n    for (var i = 1; i < len; i++) {\n      path += onestep(pts[i - 1], pts[i], i === len - 1);\n    }\n    return path;\n  };\n};\nfunction applyBackoff(pt, start) {\n  var backoff = pt.backoff;\n  var trace = pt.trace;\n  var d = pt.d;\n  var i = pt.i;\n  if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== 'spline') {\n    var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n    var end = pt;\n    var x1 = start ? start[0] : lastDrawnX || 0;\n    var y1 = start ? start[1] : lastDrawnY || 0;\n    var x2 = end[0];\n    var y2 = end[1];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var t = Math.atan2(dy, dx);\n    var b = arrayBackoff ? backoff[i] : backoff;\n    if (b === 'auto') {\n      var endI = end.i;\n      if (trace.type === 'scatter') endI--; // Why we need this hack?\n\n      var endMarker = end.marker;\n      var endMarkerSymbol = endMarker.symbol;\n      if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n      var endMarkerSize = endMarker.size;\n      if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n      b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n      b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n    }\n    var x = x2 - b * Math.cos(t);\n    var y = y2 - b * Math.sin(t);\n    if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {\n      pt = [x, y];\n    }\n  }\n  return pt;\n}\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function () {\n  var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function (s) {\n    s.attr(xmlnsNamespaces.svgAttrs).style({\n      position: 'absolute',\n      left: '-10000px',\n      top: '-10000px',\n      width: '9000px',\n      height: '9000px',\n      'z-index': '1'\n    });\n  });\n\n  // browsers differ on how they describe the bounding rect of\n  // the svg if its contents spill over... so make a 1x1px\n  // reference point we can measure off of.\n  var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function (s) {\n    s.attr('d', 'M0,0H1V1H0Z').style({\n      'stroke-width': 0,\n      fill: 'black'\n    });\n  });\n  drawing.tester = tester;\n  drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\ndrawing.bBox = function (node, inTester, hash) {\n  /*\n   * Cache elements we've already measured so we don't have to\n   * remeasure the same thing many times\n   * We have a few bBox callers though who pass a node larger than\n   * a <text> or a MathJax <g>, such as an axis group containing many labels.\n   * These will not generate a hash (unless we figure out an appropriate\n   * hash key for them) and thus we will not hash them.\n   */\n  if (!hash) hash = nodeHash(node);\n  var out;\n  if (hash) {\n    out = drawing.savedBBoxes[hash];\n    if (out) return Lib.extendFlat({}, out);\n  } else if (node.childNodes.length === 1) {\n    /*\n     * If we have only one child element, which is itself hashable, make\n     * a new hash from this element plus its x,y,transform\n     * These bounding boxes *include* x,y,transform - mostly for use by\n     * callers trying to avoid overlaps (ie titles)\n     */\n    var innerNode = node.childNodes[0];\n    hash = nodeHash(innerNode);\n    if (hash) {\n      var x = +innerNode.getAttribute('x') || 0;\n      var y = +innerNode.getAttribute('y') || 0;\n      var transform = innerNode.getAttribute('transform');\n      if (!transform) {\n        // in this case, just varying x and y, don't bother caching\n        // the final bBox because the alteration is quick.\n        var innerBB = drawing.bBox(innerNode, false, hash);\n        if (x) {\n          innerBB.left += x;\n          innerBB.right += x;\n        }\n        if (y) {\n          innerBB.top += y;\n          innerBB.bottom += y;\n        }\n        return innerBB;\n      }\n      /*\n       * else we have a transform - rather than make a complicated\n       * (and error-prone and probably slow) transform parser/calculator,\n       * just continue on calculating the boundingClientRect of the group\n       * and use the new composite hash to cache it.\n       * That said, `innerNode.transform.baseVal` is an array of\n       * `SVGTransform` objects, that *do* seem to have a nice matrix\n       * multiplication interface that we could use to avoid making\n       * another getBoundingClientRect call...\n       */\n      hash += '~' + x + '~' + y + '~' + transform;\n      out = drawing.savedBBoxes[hash];\n      if (out) return Lib.extendFlat({}, out);\n    }\n  }\n  var testNode, tester;\n  if (inTester) {\n    testNode = node;\n  } else {\n    tester = drawing.tester.node();\n\n    // copy the node to test into the tester\n    testNode = node.cloneNode(true);\n    tester.appendChild(testNode);\n  }\n\n  // standardize its position (and newline tspans if any)\n  d3.select(testNode).attr('transform', null).call(svgTextUtils.positionText, 0, 0);\n  var testRect = testNode.getBoundingClientRect();\n  var refRect = drawing.testref.node().getBoundingClientRect();\n  if (!inTester) tester.removeChild(testNode);\n  var bb = {\n    height: testRect.height,\n    width: testRect.width,\n    left: testRect.left - refRect.left,\n    top: testRect.top - refRect.top,\n    right: testRect.right - refRect.left,\n    bottom: testRect.bottom - refRect.top\n  };\n\n  // make sure we don't have too many saved boxes,\n  // or a long session could overload on memory\n  // by saving boxes for long-gone elements\n  if (savedBBoxesCount >= maxSavedBBoxes) {\n    drawing.savedBBoxes = {};\n    savedBBoxesCount = 0;\n  }\n\n  // cache this bbox\n  if (hash) drawing.savedBBoxes[hash] = bb;\n  savedBBoxesCount++;\n  return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n  var inputText = node.getAttribute('data-unformatted');\n  if (inputText === null) return;\n  return inputText + node.getAttribute('data-math') + node.getAttribute('text-anchor') + node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function (s, localId, gd) {\n  s.attr('clip-path', getFullUrl(localId, gd));\n};\nfunction getFullUrl(localId, gd) {\n  if (!localId) return null;\n  var context = gd._context;\n  var baseUrl = context._exportedPlot ? '' : context._baseUrl || '';\n  return baseUrl ? 'url(\\'' + baseUrl + '#' + localId + '\\')' : 'url(#' + localId + ')';\n}\ndrawing.getTranslate = function (element) {\n  // Note the separator [^\\d] between x and y in this regex\n  // We generally use ',' but IE will convert it to ' '\n  var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 0,\n    y: +translate[1] || 0\n  };\n};\ndrawing.setTranslate = function (element, x, y) {\n  var re = /(\\btranslate\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 0;\n  y = y || 0;\n  transform = transform.replace(re, '').trim();\n  transform += strTranslate(x, y);\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\ndrawing.getScale = function (element) {\n  var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 1,\n    y: +translate[1] || 1\n  };\n};\ndrawing.setScale = function (element, x, y) {\n  var re = /(\\bscale\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 1;\n  y = y || 1;\n  transform = transform.replace(re, '').trim();\n  transform += 'scale(' + x + ',' + y + ')';\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\nvar SCALE_RE = /\\s*sc.*/;\ndrawing.setPointGroupScale = function (selection, xScale, yScale) {\n  xScale = xScale || 1;\n  yScale = yScale || 1;\n  if (!selection) return;\n\n  // The same scale transform for every point:\n  var scale = xScale === 1 && yScale === 1 ? '' : 'scale(' + xScale + ',' + yScale + ')';\n  selection.each(function () {\n    var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n    t += scale;\n    t = t.trim();\n    this.setAttribute('transform', t);\n  });\n};\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\ndrawing.setTextPointsScale = function (selection, xScale, yScale) {\n  if (!selection) return;\n  selection.each(function () {\n    var transforms;\n    var el = d3.select(this);\n    var text = el.select('text');\n    if (!text.node()) return;\n    var x = parseFloat(text.attr('x') || 0);\n    var y = parseFloat(text.attr('y') || 0);\n    var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n    if (xScale === 1 && yScale === 1) {\n      transforms = [];\n    } else {\n      transforms = [strTranslate(x, y), 'scale(' + xScale + ',' + yScale + ')', strTranslate(-x, -y)];\n    }\n    if (existingTransform) {\n      transforms.push(existingTransform);\n    }\n    el.attr('transform', transforms.join(''));\n  });\n};\nfunction getMarkerStandoff(d, trace) {\n  var standoff;\n  if (d) standoff = d.mf;\n  if (standoff === undefined) {\n    standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n  }\n  if (!trace._geo && !trace._xA) {\n    // case of legends\n    return -standoff;\n  }\n  return standoff;\n}\ndrawing.getMarkerStandoff = getMarkerStandoff;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\nfunction rotate(t, xy) {\n  var x = xy[0];\n  var y = xy[1];\n  return [x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)];\n}\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\nfunction getMarkerAngle(d, trace) {\n  var angle = d.ma;\n  if (angle === undefined) {\n    angle = trace.marker.angle || 0;\n  }\n  var x, y;\n  var ref = trace.marker.angleref;\n  if (ref === 'previous' || ref === 'north') {\n    if (trace._geo) {\n      var p = trace._geo.project(d.lonlat);\n      x = p[0];\n      y = p[1];\n    } else {\n      var xa = trace._xA;\n      var ya = trace._yA;\n      if (xa && ya) {\n        x = xa.c2p(d.x);\n        y = ya.c2p(d.y);\n      } else {\n        // case of legends\n        return 90;\n      }\n    }\n    if (trace._geo) {\n      var lon = d.lonlat[0];\n      var lat = d.lonlat[1];\n      var north = trace._geo.project([lon, lat + 1e-5 // epsilon\n      ]);\n      var east = trace._geo.project([lon + 1e-5,\n      // epsilon\n      lat]);\n      var u = atan2(east[1] - y, east[0] - x);\n      var v = atan2(north[1] - y, north[0] - x);\n      var t;\n      if (ref === 'north') {\n        t = angle / 180 * Math.PI;\n        // To use counter-clockwise angles i.e.\n        // East: 90, West: -90\n        // to facilitate wind visualisations\n        // in future we should use t = -t here.\n      } else if (ref === 'previous') {\n        var lon1 = lon / 180 * Math.PI;\n        var lat1 = lat / 180 * Math.PI;\n        var lon2 = previousLon / 180 * Math.PI;\n        var lat2 = previousLat / 180 * Math.PI;\n        var dLon = lon2 - lon1;\n        var deltaY = cos(lat2) * sin(dLon);\n        var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n        t = -atan2(deltaY, deltaX) - Math.PI;\n        previousLon = lon;\n        previousLat = lat;\n      }\n      var A = rotate(u, [cos(t), 0]);\n      var B = rotate(v, [sin(t), 0]);\n      angle = atan2(A[1] + B[1], A[0] + B[0]) / Math.PI * 180;\n      if (ref === 'previous' && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {\n        angle = null;\n      }\n    }\n    if (ref === 'previous' && !trace._geo) {\n      if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {\n        var dX = x - previousX;\n        var dY = y - previousY;\n        var shape = trace.line ? trace.line.shape || '' : '';\n        var lastShapeChar = shape.slice(shape.length - 1);\n        if (lastShapeChar === 'h') dY = 0;\n        if (lastShapeChar === 'v') dX = 0;\n        angle += atan2(dY, dX) / Math.PI * 180 + 90;\n      } else {\n        angle = null;\n      }\n    }\n  }\n  previousX = x;\n  previousY = y;\n  previousI = d.i;\n  previousTraceUid = trace.uid;\n  return angle;\n}\ndrawing.getMarkerAngle = getMarkerAngle;","map":{"version":3,"names":["d3","require","Lib","numberFormat","isNumeric","tinycolor","Registry","Color","Colorscale","strTranslate","svgTextUtils","xmlnsNamespaces","alignment","LINE_SPACING","DESELECTDIM","subTypes","makeBubbleSizeFn","appendArrayPointValue","drawing","module","exports","font","s","family","size","color","isPlainObject","style","call","fill","setPosition","x","y","attr","setSize","w","h","setRect","translatePoint","d","sel","xa","ya","c2p","node","nodeName","translatePoints","each","select","hideOutsideRangePoint","xcalendar","ycalendar","isPtWithinRange","hideOutsideRangePoints","traceGroups","subplot","_hasClipOnAxisFalse","xaxis","yaxis","trace","selector","traceIs","selectAll","crispRound","gd","lineWidth","dflt","_context","staticPlot","Math","round","singleLineStyle","lw","lc","ld","line","lw1","width","dash","stroke","dashLine","lineGroupStyle","dashStyle","dlw","max","setFillStyle","markerPattern","fillpattern","patternShape","getPatternAttr","shape","patternBGColor","bgcolor","patternFGColor","fgcolor","patternFGOpacity","fgopacity","patternSize","patternSolidity","solidity","patternID","uid","pattern","undefined","fillmode","fillcolor","singleFillStyle","data","fillGroupStyle","SYMBOLDEFS","symbolNames","symbolFuncs","symbolBackOffs","symbolNeedLines","symbolNoDot","symbolNoFill","symbolList","Object","keys","forEach","k","symDef","n","push","String","f","backoff","needLine","noDot","noFill","MAXSYMBOL","length","DOTPATH","symbolNumber","v","vbase","indexOf","replace","floor","makePointPath","r","t","base","HORZGRADIENT","x1","x2","y1","y2","VERTGRADIENT","stopFormatter","gradientInfo","radial","radialreversed","reversed","horizontal","attrs","horizontalreversed","vertical","verticalreversed","gradient","gradientID","type","colorscale","prop","len","info","colorStops","Array","i","fullLayout","_fullLayout","fullID","_uid","_defs","join","identity","exit","remove","enter","append","el","stops","tc","offset","tinyRGB","getAlpha","getFullUrl","classed","calledBy","mcc","isLegend","contrast","height","linearFn","x0","y0","path","linewidth","radius","patternTag","patternAttrs","fgC","fgRGB","fgAlpha","opacity","sqrt","PI","cx","cy","str","id","patternUnits","patternTransform","bgC","bgRGB","bgAlpha","rects","patterns","initGradients","gradientsGroup","ensureSingle","initPatterns","patternsGroup","mp","isArrayOrTypedArray","pointStyle","pt","fns","makePointStyleFns","singlePointStyle","marker","markerLine","selectedOpacityFn","mo","ms2mrc","ms","mrc","selectedSizeFn","mx","symbol","om","angle","getMarkerAngle","standoff","getMarkerStandoff","perPointGradient","fillColor","lineColor","so","outlierwidth","outliercolor","markerLineWidth","mlw","mlcc","lineScale","mlc","defaultLine","markerScale","mc","colors","selectedColorFn","isBlank","markerGradient","gradientType","mgt","gradientColor","mgc","perPointPattern","out","tryColorscale","isBubble","selectedpoints","extendFlat","makeSelectedPointStyleFns","selectedAttrs","selected","unselectedAttrs","unselected","selectedMarker","unselectedMarker","smo","usmo","smoIsDefined","usmoIsDefined","smc","usmc","sms","usms","smsIsDefined","usmsIsDefined","makeSelectedTextStyleFns","textFont","textfont","selectedTextFont","unselectedTextFont","stc","utc","selectedTextColorFn","addOpacity","selectedPointStyle","seq","mrc2","prefix","cont","nestedProperty","get","colorArray","_colorAx","makeColorScaleFuncFromTrace","TEXTOFFSETSIGN","start","end","middle","bottom","top","textPointPosition","textPosition","fontSize","markerRadius","dontTouchParent","group","parentNode","numLines","lineCount","dx","dy","extracTextFontSize","ts","textPointStyle","texttemplate","p","text","extractOption","fn","_module","formatLabels","labels","pointValues","meta","_meta","texttemplateString","_d3locale","pos","tp","textposition","fontColor","tf","convertToTspans","selectedTextStyle","tx","CatmullRomExp","smoothopen","pts","smoothness","tangents","makeTangent","smoothclosed","pLast","lastDrawnX","lastDrawnY","roundEnd","isY","isLastPoint","applyBackoff","roundY","roundX","prevpt","thispt","nextpt","d1x","d1y","d2x","d2y","d1a","pow","d2a","numx","numy","denom1","denom2","STEPPATH","hv","p0","p1","vh","hvh","vhv","STEPLINEAR","steps","onestep","arrayBackoff","atan2","b","endI","endMarker","endMarkerSymbol","endMarkerSize","cos","sin","makeTester","tester","ensureSingleById","svgAttrs","position","left","testref","savedBBoxes","savedBBoxesCount","maxSavedBBoxes","bBox","inTester","hash","nodeHash","childNodes","innerNode","getAttribute","transform","innerBB","right","testNode","cloneNode","appendChild","positionText","testRect","getBoundingClientRect","refRect","removeChild","bb","inputText","setClipUrl","localId","context","baseUrl","_exportedPlot","_baseUrl","getTranslate","element","re","getter","translate","match","p2","split","setTranslate","setter","trim","getScale","setScale","SCALE_RE","setPointGroupScale","selection","xScale","yScale","scale","setAttribute","TEXT_POINT_LAST_TRANSLATION_RE","setTextPointsScale","transforms","parseFloat","existingTransform","mf","_geo","_xA","rotate","xy","previousLon","previousLat","previousX","previousY","previousI","previousTraceUid","ma","ref","angleref","project","lonlat","_yA","lon","lat","north","east","u","lon1","lat1","lon2","lat2","dLon","deltaY","deltaX","A","B","dX","dY","lastShapeChar","slice"],"sources":["C:/Users/Magdiel/node_modules/plotly.js/src/components/drawing/index.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function(s, family, size, color) {\n    // also allow the form font(s, {family, size, color})\n    if(Lib.isPlainObject(family)) {\n        color = family.color;\n        size = family.size;\n        family = family.family;\n    }\n    if(family) s.style('font-family', family);\n    if(size + 1) s.style('font-size', size + 'px');\n    if(color) s.call(Color.fill, color);\n};\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function(s, x, y) { s.attr('x', x).attr('y', y); };\ndrawing.setSize = function(s, w, h) { s.attr('width', w).attr('height', h); };\ndrawing.setRect = function(s, x, y, w, h) {\n    s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function(d, sel, xa, ya) {\n    var x = xa.c2p(d.x);\n    var y = ya.c2p(d.y);\n\n    if(isNumeric(x) && isNumeric(y) && sel.node()) {\n        // for multiline text this works better\n        if(sel.node().nodeName === 'text') {\n            sel.attr('x', x).attr('y', y);\n        } else {\n            sel.attr('transform', strTranslate(x, y));\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n};\n\ndrawing.translatePoints = function(s, xa, ya) {\n    s.each(function(d) {\n        var sel = d3.select(this);\n        drawing.translatePoint(d, sel, xa, ya);\n    });\n};\n\ndrawing.hideOutsideRangePoint = function(d, sel, xa, ya, xcalendar, ycalendar) {\n    sel.attr(\n        'display',\n        (xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar)) ? null : 'none'\n    );\n};\n\ndrawing.hideOutsideRangePoints = function(traceGroups, subplot) {\n    if(!subplot._hasClipOnAxisFalse) return;\n\n    var xa = subplot.xaxis;\n    var ya = subplot.yaxis;\n\n    traceGroups.each(function(d) {\n        var trace = d[0].trace;\n        var xcalendar = trace.xcalendar;\n        var ycalendar = trace.ycalendar;\n        var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n\n        traceGroups.selectAll(selector).each(function(d) {\n            drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n        });\n    });\n};\n\ndrawing.crispRound = function(gd, lineWidth, dflt) {\n    // for lines that disable antialiasing we want to\n    // make sure the width is an integer, and at least 1 if it's nonzero\n\n    if(!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n    // but not for static plots - these don't get antialiased anyway.\n    if(gd._context.staticPlot) return lineWidth;\n\n    if(lineWidth < 1) return 1;\n    return Math.round(lineWidth);\n};\n\ndrawing.singleLineStyle = function(d, s, lw, lc, ld) {\n    s.style('fill', 'none');\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n\n    Color.stroke(s, lc || line.color);\n    drawing.dashLine(s, dash, lw1);\n};\n\ndrawing.lineGroupStyle = function(s, lw, lc, ld) {\n    s.style('fill', 'none')\n    .each(function(d) {\n        var line = (((d || [])[0] || {}).trace || {}).line || {};\n        var lw1 = lw || line.width || 0;\n        var dash = ld || line.dash || '';\n\n        d3.select(this)\n            .call(Color.stroke, lc || line.color)\n            .call(drawing.dashLine, dash, lw1);\n    });\n};\n\ndrawing.dashLine = function(s, dash, lineWidth) {\n    lineWidth = +lineWidth || 0;\n\n    dash = drawing.dashStyle(dash, lineWidth);\n\n    s.style({\n        'stroke-dasharray': dash,\n        'stroke-width': lineWidth + 'px'\n    });\n};\n\ndrawing.dashStyle = function(dash, lineWidth) {\n    lineWidth = +lineWidth || 1;\n    var dlw = Math.max(lineWidth, 3);\n\n    if(dash === 'solid') dash = '';\n    else if(dash === 'dot') dash = dlw + 'px,' + dlw + 'px';\n    else if(dash === 'dash') dash = (3 * dlw) + 'px,' + (3 * dlw) + 'px';\n    else if(dash === 'longdash') dash = (5 * dlw) + 'px,' + (5 * dlw) + 'px';\n    else if(dash === 'dashdot') {\n        dash = (3 * dlw) + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n    } else if(dash === 'longdashdot') {\n        dash = (5 * dlw) + 'px,' + (2 * dlw) + 'px,' + dlw + 'px,' + (2 * dlw) + 'px';\n    }\n    // otherwise user wrote the dasharray themselves - leave it be\n\n    return dash;\n};\n\nfunction setFillStyle(sel, trace, gd) {\n    var markerPattern = trace.fillpattern;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n    if(patternShape) {\n        var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n        var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n        var patternFGOpacity = markerPattern.fgopacity;\n        var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n        var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n        var patternID = trace.uid;\n        drawing.pattern(sel, 'point', gd, patternID,\n            patternShape, patternSize, patternSolidity,\n            undefined, markerPattern.fillmode,\n            patternBGColor, patternFGColor, patternFGOpacity\n        );\n    } else if(trace.fillcolor) {\n        sel.call(Color.fill, trace.fillcolor);\n    }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function(sel, gd) {\n    var node = d3.select(sel.node());\n    var data = node.data();\n    var trace = ((data[0] || [])[0] || {}).trace || {};\n    setFillStyle(sel, trace, gd);\n};\n\ndrawing.fillGroupStyle = function(s, gd) {\n    s.style('stroke-width', 0)\n    .each(function(d) {\n        var shape = d3.select(this);\n        // N.B. 'd' won't be a calcdata item when\n        // fill !== 'none' on a segment-less and marker-less trace\n        if(d[0].trace) {\n            setFillStyle(shape, d[0].trace, gd);\n        }\n    });\n};\n\nvar SYMBOLDEFS = require('./symbol_defs');\n\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\n\nObject.keys(SYMBOLDEFS).forEach(function(k) {\n    var symDef = SYMBOLDEFS[k];\n    var n = symDef.n;\n    drawing.symbolList.push(\n        n,\n        String(n),\n        k,\n\n        n + 100,\n        String(n + 100),\n        k + '-open'\n    );\n    drawing.symbolNames[n] = k;\n    drawing.symbolFuncs[n] = symDef.f;\n    drawing.symbolBackOffs[n] = symDef.backoff || 0;\n\n    if(symDef.needLine) {\n        drawing.symbolNeedLines[n] = true;\n    }\n    if(symDef.noDot) {\n        drawing.symbolNoDot[n] = true;\n    } else {\n        drawing.symbolList.push(\n            n + 200,\n            String(n + 200),\n            k + '-dot',\n\n            n + 300,\n            String(n + 300),\n            k + '-open-dot'\n        );\n    }\n    if(symDef.noFill) {\n        drawing.symbolNoFill[n] = true;\n    }\n});\n\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\n\ndrawing.symbolNumber = function(v) {\n    if(isNumeric(v)) {\n        v = +v;\n    } else if(typeof v === 'string') {\n        var vbase = 0;\n        if(v.indexOf('-open') > 0) {\n            vbase = 100;\n            v = v.replace('-open', '');\n        }\n        if(v.indexOf('-dot') > 0) {\n            vbase += 200;\n            v = v.replace('-dot', '');\n        }\n        v = drawing.symbolNames.indexOf(v);\n        if(v >= 0) { v += vbase; }\n    }\n\n    return (v % 100 >= MAXSYMBOL || v >= 400) ?\n        0 : Math.floor(Math.max(v, 0));\n};\n\nfunction makePointPath(symbolNumber, r, t, s) {\n    var base = symbolNumber % 100;\n    return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\n\nvar HORZGRADIENT = {x1: 1, x2: 0, y1: 0, y2: 0};\nvar VERTGRADIENT = {x1: 0, x2: 0, y1: 1, y2: 0};\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n    radial: {node: 'radialGradient'},\n    radialreversed: {node: 'radialGradient', reversed: true},\n    horizontal: {node: 'linearGradient', attrs: HORZGRADIENT},\n    horizontalreversed: {node: 'linearGradient', attrs: HORZGRADIENT, reversed: true},\n    vertical: {node: 'linearGradient', attrs: VERTGRADIENT},\n    verticalreversed: {node: 'linearGradient', attrs: VERTGRADIENT, reversed: true}\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function(sel, gd, gradientID, type, colorscale, prop) {\n    var len = colorscale.length;\n    var info = gradientInfo[type];\n    var colorStops = new Array(len);\n    for(var i = 0; i < len; i++) {\n        if(info.reversed) {\n            colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n        } else {\n            colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n\n    var gradient = fullLayout._defs.select('.gradients')\n        .selectAll('#' + fullID)\n        .data([type + colorStops.join(';')], Lib.identity);\n\n    gradient.exit().remove();\n\n    gradient.enter()\n        .append(info.node)\n        .each(function() {\n            var el = d3.select(this);\n            if(info.attrs) el.attr(info.attrs);\n\n            el.attr('id', fullID);\n\n            var stops = el.selectAll('stop')\n                .data(colorStops);\n            stops.exit().remove();\n            stops.enter().append('stop');\n\n            stops.each(function(d) {\n                var tc = tinycolor(d[1]);\n                d3.select(this).attr({\n                    offset: d[0] + '%',\n                    'stop-color': Color.tinyRGB(tc),\n                    'stop-opacity': tc.getAlpha()\n                });\n            });\n        });\n\n    sel.style(prop, getFullUrl(fullID, gd))\n        .style(prop + '-opacity', null);\n\n    sel.classed('gradient_filled', true);\n};\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n    var isLegend = calledBy === 'legend';\n\n    if(mcc) {\n        if(fillmode === 'overlay') {\n            bgcolor = mcc;\n            fgcolor = Color.contrast(bgcolor);\n        } else {\n            bgcolor = undefined;\n            fgcolor = mcc;\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'p' + fullLayout._uid + '-' + patternID;\n    var width, height;\n\n    // linear interpolation\n    var linearFn = function(x, x0, x1, y0, y1) {\n        return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n    };\n\n    var path, linewidth, radius;\n    var patternTag;\n    var patternAttrs = {};\n\n    var fgC = tinycolor(fgcolor);\n    var fgRGB = Color.tinyRGB(fgC);\n    var fgAlpha = fgC.getAlpha();\n    var opacity = fgopacity * fgAlpha;\n\n    switch(shape) {\n        case '/':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '\\\\':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case 'x':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '|':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height;\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '-':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '+':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height +\n                   'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '.':\n            width = size;\n            height = size;\n            if(solidity < Math.PI / 4) {\n                radius = Math.sqrt(solidity * size * size / Math.PI);\n            } else {\n                radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n            }\n            patternTag = 'circle';\n            patternAttrs = {\n                cx: width / 2,\n                cy: height / 2,\n                r: radius,\n                opacity: opacity,\n                fill: fgRGB\n            };\n            break;\n    }\n\n    var str = [\n        shape || 'noSh',\n        bgcolor || 'noBg',\n        fgcolor || 'noFg',\n        size,\n        solidity\n    ].join(';');\n\n    var pattern = fullLayout._defs.select('.patterns')\n        .selectAll('#' + fullID)\n        .data([str], Lib.identity);\n\n    pattern.exit().remove();\n\n    pattern.enter()\n        .append('pattern')\n        .each(function() {\n            var el = d3.select(this);\n\n            el.attr({\n                id: fullID,\n                width: width + 'px',\n                height: height + 'px',\n                patternUnits: 'userSpaceOnUse',\n                // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n                patternTransform: isLegend ? 'scale(0.8)' : ''\n            });\n\n            if(bgcolor) {\n                var bgC = tinycolor(bgcolor);\n                var bgRGB = Color.tinyRGB(bgC);\n                var bgAlpha = bgC.getAlpha();\n\n                var rects = el.selectAll('rect').data([0]);\n                rects.exit().remove();\n                rects.enter()\n                    .append('rect')\n                    .attr({\n                        width: width + 'px',\n                        height: height + 'px',\n                        fill: bgRGB,\n                        'fill-opacity': bgAlpha,\n                    });\n            }\n\n            var patterns = el.selectAll(patternTag).data([0]);\n            patterns.exit().remove();\n            patterns.enter()\n                .append(patternTag)\n                .attr(patternAttrs);\n        });\n\n    sel.style('fill', getFullUrl(fullID, gd))\n        .style('fill-opacity', null);\n\n    sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n    gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n\n    d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\n\ndrawing.initPatterns = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n    patternsGroup.selectAll('pattern').remove();\n\n    d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\n\ndrawing.getPatternAttr = function(mp, i, dflt) {\n    if(mp && Lib.isArrayOrTypedArray(mp)) {\n        return i < mp.length ? mp[i] : dflt;\n    }\n    return mp;\n};\n\ndrawing.pointStyle = function(s, trace, gd, pt) {\n    if(!s.size()) return;\n\n    var fns = drawing.makePointStyleFns(trace);\n\n    s.each(function(d) {\n        drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);\n    });\n};\n\ndrawing.singlePointStyle = function(d, sel, trace, fns, gd, pt) {\n    var marker = trace.marker;\n    var markerLine = marker.line;\n\n    if(pt && pt.i >= 0 && d.i === undefined) d.i = pt.i;\n\n    sel.style('opacity',\n        fns.selectedOpacityFn ? fns.selectedOpacityFn(d) :\n            (d.mo === undefined ? marker.opacity : d.mo)\n    );\n\n    if(fns.ms2mrc) {\n        var r;\n\n        // handle multi-trace graph edit case\n        if(d.ms === 'various' || marker.size === 'various') {\n            r = 3;\n        } else {\n            r = fns.ms2mrc(d.ms);\n        }\n\n        // store the calculated size so hover can use it\n        d.mrc = r;\n\n        if(fns.selectedSizeFn) {\n            r = d.mrc = fns.selectedSizeFn(d);\n        }\n\n        // turn the symbol into a sanitized number\n        var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n        // save if this marker is open\n        // because that impacts how to handle colors\n        d.om = x % 200 >= 100;\n\n        var angle = getMarkerAngle(d, trace);\n        var standoff = getMarkerStandoff(d, trace);\n\n        sel.attr('d', makePointPath(x, r, angle, standoff));\n    }\n\n    var perPointGradient = false;\n    var fillColor, lineColor, lineWidth;\n\n    // 'so' is suspected outliers, for box plots\n    if(d.so) {\n        lineWidth = markerLine.outlierwidth;\n        lineColor = markerLine.outliercolor;\n        fillColor = marker.outliercolor;\n    } else {\n        var markerLineWidth = (markerLine || {}).width;\n\n        lineWidth = (\n            d.mlw + 1 ||\n            markerLineWidth + 1 ||\n            // TODO: we need the latter for legends... can we get rid of it?\n            (d.trace ? (d.trace.marker.line || {}).width : 0) + 1\n        ) - 1 || 0;\n\n        if('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n        // weird case: array wasn't long enough to apply to every point\n        else if(Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;\n        else lineColor = markerLine.color;\n\n        if(Lib.isArrayOrTypedArray(marker.color)) {\n            fillColor = Color.defaultLine;\n            perPointGradient = true;\n        }\n\n        if('mc' in d) {\n            fillColor = d.mcc = fns.markerScale(d.mc);\n        } else {\n            fillColor = marker.color || marker.colors || 'rgba(0,0,0,0)';\n        }\n\n        if(fns.selectedColorFn) {\n            fillColor = fns.selectedColorFn(d);\n        }\n    }\n\n    if(d.om) {\n        // open markers can't have zero linewidth, default to 1px,\n        // and use fill color as stroke color\n        sel.call(Color.stroke, fillColor)\n            .style({\n                'stroke-width': (lineWidth || 1) + 'px',\n                fill: 'none'\n            });\n    } else {\n        sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n\n        var markerGradient = marker.gradient;\n\n        var gradientType = d.mgt;\n        if(gradientType) perPointGradient = true;\n        else gradientType = markerGradient && markerGradient.type;\n\n        // for legend - arrays will propagate through here, but we don't need\n        // to treat it as per-point.\n        if(Lib.isArrayOrTypedArray(gradientType)) {\n            gradientType = gradientType[0];\n            if(!gradientInfo[gradientType]) gradientType = 0;\n        }\n\n        var markerPattern = marker.pattern;\n        var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n\n        if(gradientType && gradientType !== 'none') {\n            var gradientColor = d.mgc;\n            if(gradientColor) perPointGradient = true;\n            else gradientColor = markerGradient.color;\n\n            var gradientID = trace.uid;\n            if(perPointGradient) gradientID += '-' + d.i;\n\n            drawing.gradient(sel, gd, gradientID, gradientType,\n                [[0, gradientColor], [1, fillColor]], 'fill');\n        } else if(patternShape) {\n            var perPointPattern = false;\n            var fgcolor = markerPattern.fgcolor;\n            if(!fgcolor && pt && pt.color) {\n                fgcolor = pt.color;\n                perPointPattern = true;\n            }\n            var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, (pt && pt.color) || null);\n\n            var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n            var patternFGOpacity = markerPattern.fgopacity;\n            var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n            var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n            perPointPattern = perPointPattern || d.mcc ||\n                Lib.isArrayOrTypedArray(markerPattern.shape) ||\n                Lib.isArrayOrTypedArray(markerPattern.bgcolor) ||\n                Lib.isArrayOrTypedArray(markerPattern.fgcolor) ||\n                Lib.isArrayOrTypedArray(markerPattern.size) ||\n                Lib.isArrayOrTypedArray(markerPattern.solidity);\n\n            var patternID = trace.uid;\n            if(perPointPattern) patternID += '-' + d.i;\n\n            drawing.pattern(\n                sel, 'point', gd, patternID,\n                patternShape, patternSize, patternSolidity,\n                d.mcc, markerPattern.fillmode,\n                patternBGColor, patternFGColor, patternFGOpacity\n            );\n        } else {\n            Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);\n        }\n\n        if(lineWidth) {\n            Color.stroke(sel, lineColor);\n        }\n    }\n};\n\ndrawing.makePointStyleFns = function(trace) {\n    var out = {};\n    var marker = trace.marker;\n\n    // allow array marker and marker line colors to be\n    // scaled by given max and min to colorscales\n    out.markerScale = drawing.tryColorscale(marker, '');\n    out.lineScale = drawing.tryColorscale(marker, 'line');\n\n    if(Registry.traceIs(trace, 'symbols')) {\n        out.ms2mrc = subTypes.isBubble(trace) ?\n            makeBubbleSizeFn(trace) :\n            function() { return (marker.size || 6) / 2; };\n    }\n\n    if(trace.selectedpoints) {\n        Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedPointStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var marker = trace.marker || {};\n    var selectedMarker = selectedAttrs.marker || {};\n    var unselectedMarker = unselectedAttrs.marker || {};\n\n    var mo = marker.opacity;\n    var smo = selectedMarker.opacity;\n    var usmo = unselectedMarker.opacity;\n    var smoIsDefined = smo !== undefined;\n    var usmoIsDefined = usmo !== undefined;\n\n    if(Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n        out.selectedOpacityFn = function(d) {\n            var base = d.mo === undefined ? marker.opacity : d.mo;\n\n            if(d.selected) {\n                return smoIsDefined ? smo : base;\n            } else {\n                return usmoIsDefined ? usmo : DESELECTDIM * base;\n            }\n        };\n    }\n\n    var mc = marker.color;\n    var smc = selectedMarker.color;\n    var usmc = unselectedMarker.color;\n\n    if(smc || usmc) {\n        out.selectedColorFn = function(d) {\n            var base = d.mcc || mc;\n\n            if(d.selected) {\n                return smc || base;\n            } else {\n                return usmc || base;\n            }\n        };\n    }\n\n    var ms = marker.size;\n    var sms = selectedMarker.size;\n    var usms = unselectedMarker.size;\n    var smsIsDefined = sms !== undefined;\n    var usmsIsDefined = usms !== undefined;\n\n    if(Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n        out.selectedSizeFn = function(d) {\n            var base = d.mrc || ms / 2;\n\n            if(d.selected) {\n                return smsIsDefined ? sms / 2 : base;\n            } else {\n                return usmsIsDefined ? usms / 2 : base;\n            }\n        };\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedTextStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var textFont = trace.textfont || {};\n    var selectedTextFont = selectedAttrs.textfont || {};\n    var unselectedTextFont = unselectedAttrs.textfont || {};\n\n    var tc = textFont.color;\n    var stc = selectedTextFont.color;\n    var utc = unselectedTextFont.color;\n\n    out.selectedTextColorFn = function(d) {\n        var base = d.tc || tc;\n\n        if(d.selected) {\n            return stc || base;\n        } else {\n            if(utc) return utc;\n            else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n        }\n    };\n\n    return out;\n};\n\ndrawing.selectedPointStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedPointStyleFns(trace);\n    var marker = trace.marker || {};\n    var seq = [];\n\n    if(fns.selectedOpacityFn) {\n        seq.push(function(pt, d) {\n            pt.style('opacity', fns.selectedOpacityFn(d));\n        });\n    }\n\n    if(fns.selectedColorFn) {\n        seq.push(function(pt, d) {\n            Color.fill(pt, fns.selectedColorFn(d));\n        });\n    }\n\n    if(fns.selectedSizeFn) {\n        seq.push(function(pt, d) {\n            var mx = d.mx || marker.symbol || 0;\n            var mrc2 = fns.selectedSizeFn(d);\n\n            pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n            // save for Drawing.selectedTextStyle\n            d.mrc2 = mrc2;\n        });\n    }\n\n    if(seq.length) {\n        s.each(function(d) {\n            var pt = d3.select(this);\n            for(var i = 0; i < seq.length; i++) {\n                seq[i](pt, d);\n            }\n        });\n    }\n};\n\ndrawing.tryColorscale = function(marker, prefix) {\n    var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n\n    if(cont) {\n        var colorArray = cont.color;\n        if((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n            return Colorscale.makeColorScaleFuncFromTrace(cont);\n        }\n    }\n    return Lib.identity;\n};\n\nvar TEXTOFFSETSIGN = {\n    start: 1, end: -1, middle: 0, bottom: 1, top: -1\n};\n\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n    var group = d3.select(s.node().parentNode);\n\n    var v = textPosition.indexOf('top') !== -1 ?\n        'top' :\n        textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n    var h = textPosition.indexOf('left') !== -1 ?\n        'end' :\n        textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n    // if markers are shown, offset a little more than\n    // the nominal marker size\n    // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n    var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n\n    var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n    var dx = TEXTOFFSETSIGN[h] * r;\n    var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r +\n        (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n    // fix the overall text group position\n    s.attr('text-anchor', h);\n    if(!dontTouchParent) {\n        group.attr('transform', strTranslate(dx, dy));\n    }\n}\n\nfunction extracTextFontSize(d, trace) {\n    var fontSize = d.ts || trace.textfont.size;\n    return (isNumeric(fontSize) && fontSize > 0) ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function(s, trace, gd) {\n    if(!s.size()) return;\n\n    var selectedTextColorFn;\n    if(trace.selectedpoints) {\n        var fns = drawing.makeSelectedTextStyleFns(trace);\n        selectedTextColorFn = fns.selectedTextColorFn;\n    }\n\n    var texttemplate = trace.texttemplate;\n    var fullLayout = gd._fullLayout;\n\n    s.each(function(d) {\n        var p = d3.select(this);\n\n        var text = texttemplate ?\n            Lib.extractOption(d, trace, 'txt', 'texttemplate') :\n            Lib.extractOption(d, trace, 'tx', 'text');\n\n        if(!text && text !== 0) {\n            p.remove();\n            return;\n        }\n\n        if(texttemplate) {\n            var fn = trace._module.formatLabels;\n            var labels = fn ? fn(d, trace, fullLayout) : {};\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, d.i);\n            var meta = trace._meta || {};\n            text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n        }\n\n        var pos = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n        var fontColor = selectedTextColorFn ?\n            selectedTextColorFn(d) :\n            (d.tc || trace.textfont.color);\n\n        p.call(drawing.font,\n                d.tf || trace.textfont.family,\n                fontSize,\n                fontColor)\n            .text(text)\n            .call(svgTextUtils.convertToTspans, gd)\n            .call(textPointPosition, pos, fontSize, d.mrc);\n    });\n};\n\ndrawing.selectedTextStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n\n    s.each(function(d) {\n        var tx = d3.select(this);\n        var tc = fns.selectedTextColorFn(d);\n        var tp = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n\n        Color.fill(tx, tc);\n        var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n        textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n    });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L');}\n    var path = 'M' + pts[0];\n    var tangents = [];\n    var i;\n    for(i = 1; i < pts.length - 1; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    path += 'Q' + tangents[0][0] + ' ' + pts[1];\n    for(i = 2; i < pts.length - 1; i++) {\n        path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n    }\n    path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n    return path;\n};\n\ndrawing.smoothclosed = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L') + 'Z'; }\n    var path = 'M' + pts[0];\n    var pLast = pts.length - 1;\n    var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n    var i;\n    for(i = 1; i < pLast; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    tangents.push(\n        makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)\n    );\n\n    for(i = 1; i <= pLast; i++) {\n        path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n    }\n    path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n    return path;\n};\n\nvar lastDrawnX, lastDrawnY;\n\nfunction roundEnd(pt, isY, isLastPoint) {\n    if(isLastPoint) pt = applyBackoff(pt);\n\n    return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\n\nfunction roundX(p) {\n    var v = d3.round(p, 2);\n    lastDrawnX = v;\n    return v;\n}\n\nfunction roundY(p) {\n    var v = d3.round(p, 2);\n    lastDrawnY = v;\n    return v;\n}\n\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n    var d1x = prevpt[0] - thispt[0];\n    var d1y = prevpt[1] - thispt[1];\n    var d2x = nextpt[0] - thispt[0];\n    var d2y = nextpt[1] - thispt[1];\n    var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n    var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n    var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n    var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n    var denom1 = 3 * d2a * (d1a + d2a);\n    var denom2 = 3 * d1a * (d1a + d2a);\n    return [\n        [\n            roundX(thispt[0] + (denom1 && numx / denom1)),\n            roundY(thispt[1] + (denom1 && numy / denom1))\n        ], [\n            roundX(thispt[0] - (denom2 && numx / denom2)),\n            roundY(thispt[1] - (denom2 && numy / denom2))\n        ]\n    ];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n    hv: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    },\n    vh: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    hvh: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX((p0[0] + p1[0]) / 2) + 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    vhv: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY((p0[1] + p1[1]) / 2) + 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    }\n};\nvar STEPLINEAR = function(p0, p1, isLastPoint) {\n    return 'L' +\n        roundEnd(p1, 0, isLastPoint) + ',' +\n        roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function(shape) {\n    var onestep = STEPPATH[shape] || STEPLINEAR;\n    return function(pts) {\n        var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n        var len = pts.length;\n        for(var i = 1; i < len; i++) {\n            path += onestep(pts[i - 1], pts[i], i === len - 1);\n        }\n        return path;\n    };\n};\n\nfunction applyBackoff(pt, start) {\n    var backoff = pt.backoff;\n    var trace = pt.trace;\n    var d = pt.d;\n    var i = pt.i;\n\n    if(backoff && trace &&\n        trace.marker &&\n        trace.marker.angle % 360 === 0 &&\n        trace.line &&\n        trace.line.shape !== 'spline'\n    ) {\n        var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n        var end = pt;\n\n        var x1 = start ? start[0] : lastDrawnX || 0;\n        var y1 = start ? start[1] : lastDrawnY || 0;\n\n        var x2 = end[0];\n        var y2 = end[1];\n\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n\n        var t = Math.atan2(dy, dx);\n\n        var b = arrayBackoff ? backoff[i] : backoff;\n\n        if(b === 'auto') {\n            var endI = end.i;\n            if(trace.type === 'scatter') endI--; // Why we need this hack?\n\n            var endMarker = end.marker;\n            var endMarkerSymbol = endMarker.symbol;\n            if(Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n\n            var endMarkerSize = endMarker.size;\n            if(Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n\n            b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n            b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n        }\n\n        var x = x2 - b * Math.cos(t);\n        var y = y2 - b * Math.sin(t);\n\n        if(\n            ((x <= x2 && x >= x1) || (x >= x2 && x <= x1)) &&\n            ((y <= y2 && y >= y1) || (y >= y2 && y <= y1))\n        ) {\n            pt = [x, y];\n        }\n    }\n\n    return pt;\n}\n\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function() {\n    var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function(s) {\n        s.attr(xmlnsNamespaces.svgAttrs)\n            .style({\n                position: 'absolute',\n                left: '-10000px',\n                top: '-10000px',\n                width: '9000px',\n                height: '9000px',\n                'z-index': '1'\n            });\n    });\n\n    // browsers differ on how they describe the bounding rect of\n    // the svg if its contents spill over... so make a 1x1px\n    // reference point we can measure off of.\n    var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function(s) {\n        s.attr('d', 'M0,0H1V1H0Z')\n            .style({\n                'stroke-width': 0,\n                fill: 'black'\n            });\n    });\n\n    drawing.tester = tester;\n    drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\n\ndrawing.bBox = function(node, inTester, hash) {\n    /*\n     * Cache elements we've already measured so we don't have to\n     * remeasure the same thing many times\n     * We have a few bBox callers though who pass a node larger than\n     * a <text> or a MathJax <g>, such as an axis group containing many labels.\n     * These will not generate a hash (unless we figure out an appropriate\n     * hash key for them) and thus we will not hash them.\n     */\n    if(!hash) hash = nodeHash(node);\n    var out;\n    if(hash) {\n        out = drawing.savedBBoxes[hash];\n        if(out) return Lib.extendFlat({}, out);\n    } else if(node.childNodes.length === 1) {\n        /*\n         * If we have only one child element, which is itself hashable, make\n         * a new hash from this element plus its x,y,transform\n         * These bounding boxes *include* x,y,transform - mostly for use by\n         * callers trying to avoid overlaps (ie titles)\n         */\n        var innerNode = node.childNodes[0];\n\n        hash = nodeHash(innerNode);\n        if(hash) {\n            var x = +innerNode.getAttribute('x') || 0;\n            var y = +innerNode.getAttribute('y') || 0;\n            var transform = innerNode.getAttribute('transform');\n\n            if(!transform) {\n                // in this case, just varying x and y, don't bother caching\n                // the final bBox because the alteration is quick.\n                var innerBB = drawing.bBox(innerNode, false, hash);\n                if(x) {\n                    innerBB.left += x;\n                    innerBB.right += x;\n                }\n                if(y) {\n                    innerBB.top += y;\n                    innerBB.bottom += y;\n                }\n                return innerBB;\n            }\n            /*\n             * else we have a transform - rather than make a complicated\n             * (and error-prone and probably slow) transform parser/calculator,\n             * just continue on calculating the boundingClientRect of the group\n             * and use the new composite hash to cache it.\n             * That said, `innerNode.transform.baseVal` is an array of\n             * `SVGTransform` objects, that *do* seem to have a nice matrix\n             * multiplication interface that we could use to avoid making\n             * another getBoundingClientRect call...\n             */\n            hash += '~' + x + '~' + y + '~' + transform;\n\n            out = drawing.savedBBoxes[hash];\n            if(out) return Lib.extendFlat({}, out);\n        }\n    }\n    var testNode, tester;\n    if(inTester) {\n        testNode = node;\n    } else {\n        tester = drawing.tester.node();\n\n        // copy the node to test into the tester\n        testNode = node.cloneNode(true);\n        tester.appendChild(testNode);\n    }\n\n    // standardize its position (and newline tspans if any)\n    d3.select(testNode)\n        .attr('transform', null)\n        .call(svgTextUtils.positionText, 0, 0);\n\n    var testRect = testNode.getBoundingClientRect();\n    var refRect = drawing.testref\n        .node()\n        .getBoundingClientRect();\n\n    if(!inTester) tester.removeChild(testNode);\n\n    var bb = {\n        height: testRect.height,\n        width: testRect.width,\n        left: testRect.left - refRect.left,\n        top: testRect.top - refRect.top,\n        right: testRect.right - refRect.left,\n        bottom: testRect.bottom - refRect.top\n    };\n\n    // make sure we don't have too many saved boxes,\n    // or a long session could overload on memory\n    // by saving boxes for long-gone elements\n    if(savedBBoxesCount >= maxSavedBBoxes) {\n        drawing.savedBBoxes = {};\n        savedBBoxesCount = 0;\n    }\n\n    // cache this bbox\n    if(hash) drawing.savedBBoxes[hash] = bb;\n    savedBBoxesCount++;\n\n    return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n    var inputText = node.getAttribute('data-unformatted');\n    if(inputText === null) return;\n    return inputText +\n        node.getAttribute('data-math') +\n        node.getAttribute('text-anchor') +\n        node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function(s, localId, gd) {\n    s.attr('clip-path', getFullUrl(localId, gd));\n};\n\nfunction getFullUrl(localId, gd) {\n    if(!localId) return null;\n\n    var context = gd._context;\n    var baseUrl = context._exportedPlot ? '' : (context._baseUrl || '');\n    return baseUrl ?\n        'url(\\'' + baseUrl + '#' + localId + '\\')' :\n        'url(#' + localId + ')';\n}\n\ndrawing.getTranslate = function(element) {\n    // Note the separator [^\\d] between x and y in this regex\n    // We generally use ',' but IE will convert it to ' '\n    var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 0,\n        y: +translate[1] || 0\n    };\n};\n\ndrawing.setTranslate = function(element, x, y) {\n    var re = /(\\btranslate\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 0;\n    y = y || 0;\n\n    transform = transform.replace(re, '').trim();\n    transform += strTranslate(x, y);\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\ndrawing.getScale = function(element) {\n    var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 1,\n        y: +translate[1] || 1\n    };\n};\n\ndrawing.setScale = function(element, x, y) {\n    var re = /(\\bscale\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 1;\n    y = y || 1;\n\n    transform = transform.replace(re, '').trim();\n    transform += 'scale(' + x + ',' + y + ')';\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\nvar SCALE_RE = /\\s*sc.*/;\n\ndrawing.setPointGroupScale = function(selection, xScale, yScale) {\n    xScale = xScale || 1;\n    yScale = yScale || 1;\n\n    if(!selection) return;\n\n    // The same scale transform for every point:\n    var scale = (xScale === 1 && yScale === 1) ?\n        '' :\n        'scale(' + xScale + ',' + yScale + ')';\n\n    selection.each(function() {\n        var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n        t += scale;\n        t = t.trim();\n        this.setAttribute('transform', t);\n    });\n};\n\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\n\ndrawing.setTextPointsScale = function(selection, xScale, yScale) {\n    if(!selection) return;\n\n    selection.each(function() {\n        var transforms;\n        var el = d3.select(this);\n        var text = el.select('text');\n\n        if(!text.node()) return;\n\n        var x = parseFloat(text.attr('x') || 0);\n        var y = parseFloat(text.attr('y') || 0);\n\n        var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n\n        if(xScale === 1 && yScale === 1) {\n            transforms = [];\n        } else {\n            transforms = [\n                strTranslate(x, y),\n                'scale(' + xScale + ',' + yScale + ')',\n                strTranslate(-x, -y),\n            ];\n        }\n\n        if(existingTransform) {\n            transforms.push(existingTransform);\n        }\n\n        el.attr('transform', transforms.join(''));\n    });\n};\n\nfunction getMarkerStandoff(d, trace) {\n    var standoff;\n\n    if(d) standoff = d.mf;\n\n    if(standoff === undefined) {\n        standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n    }\n\n    if(!trace._geo && !trace._xA) {\n        // case of legends\n        return -standoff;\n    }\n\n    return standoff;\n}\n\ndrawing.getMarkerStandoff = getMarkerStandoff;\n\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\n\nfunction rotate(t, xy) {\n    var x = xy[0];\n    var y = xy[1];\n    return [\n        x * cos(t) - y * sin(t),\n        x * sin(t) + y * cos(t)\n    ];\n}\n\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\n\nfunction getMarkerAngle(d, trace) {\n    var angle = d.ma;\n\n    if(angle === undefined) {\n        angle = trace.marker.angle || 0;\n    }\n\n    var x, y;\n    var ref = trace.marker.angleref;\n    if(ref === 'previous' || ref === 'north') {\n        if(trace._geo) {\n            var p = trace._geo.project(d.lonlat);\n            x = p[0];\n            y = p[1];\n        } else {\n            var xa = trace._xA;\n            var ya = trace._yA;\n            if(xa && ya) {\n                x = xa.c2p(d.x);\n                y = ya.c2p(d.y);\n            } else {\n                // case of legends\n                return 90;\n            }\n        }\n\n        if(trace._geo) {\n            var lon = d.lonlat[0];\n            var lat = d.lonlat[1];\n\n            var north = trace._geo.project([\n                lon,\n                lat + 1e-5 // epsilon\n            ]);\n\n            var east = trace._geo.project([\n                lon + 1e-5, // epsilon\n                lat\n            ]);\n\n            var u = atan2(\n                east[1] - y,\n                east[0] - x\n            );\n\n            var v = atan2(\n                north[1] - y,\n                north[0] - x\n            );\n\n            var t;\n            if(ref === 'north') {\n                t = angle / 180 * Math.PI;\n                // To use counter-clockwise angles i.e.\n                // East: 90, West: -90\n                // to facilitate wind visualisations\n                // in future we should use t = -t here.\n            } else if(ref === 'previous') {\n                var lon1 = lon / 180 * Math.PI;\n                var lat1 = lat / 180 * Math.PI;\n                var lon2 = previousLon / 180 * Math.PI;\n                var lat2 = previousLat / 180 * Math.PI;\n\n                var dLon = lon2 - lon1;\n\n                var deltaY = cos(lat2) * sin(dLon);\n                var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n\n                t = -atan2(\n                    deltaY,\n                    deltaX\n                ) - Math.PI;\n\n                previousLon = lon;\n                previousLat = lat;\n            }\n\n            var A = rotate(u, [cos(t), 0]);\n            var B = rotate(v, [sin(t), 0]);\n\n            angle = atan2(\n                A[1] + B[1],\n                A[0] + B[0]\n            ) / Math.PI * 180;\n\n            if(ref === 'previous' && !(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1\n            )) {\n                angle = null;\n            }\n        }\n\n        if(ref === 'previous' && !trace._geo) {\n            if(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1 &&\n                isNumeric(x) &&\n                isNumeric(y)\n            ) {\n                var dX = x - previousX;\n                var dY = y - previousY;\n\n                var shape = trace.line ? trace.line.shape || '' : '';\n\n                var lastShapeChar = shape.slice(shape.length - 1);\n                if(lastShapeChar === 'h') dY = 0;\n                if(lastShapeChar === 'v') dX = 0;\n\n                angle += atan2(dY, dX) / Math.PI * 180 + 90;\n            } else {\n                angle = null;\n            }\n        }\n    }\n\n    previousX = x;\n    previousY = y;\n    previousI = d.i;\n    previousTraceUid = trace.uid;\n\n    return angle;\n}\n\ndrawing.getMarkerAngle = getMarkerAngle;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}