{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar readPaths = require('./draw_newshape/helpers').readPaths;\nvar displayOutlines = require('./display_outlines');\nvar drawLabel = require('./display_labels');\nvar clearOutlineControllers = require('./handle_outline').clearOutlineControllers;\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nvar getPathString = helpers.getPathString;\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  eraseActiveShape: eraseActiveShape,\n  drawLabel: drawLabel\n};\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n  fullLayout._shapeUpperLayer.selectAll('path').remove();\n  fullLayout._shapeLowerLayer.selectAll('path').remove();\n  fullLayout._shapeUpperLayer.selectAll('text').remove();\n  fullLayout._shapeLowerLayer.selectAll('text').remove();\n  for (var k in fullLayout._plots) {\n    var shapelayer = fullLayout._plots[k].shapelayer;\n    if (shapelayer) {\n      shapelayer.selectAll('path').remove();\n      shapelayer.selectAll('text').remove();\n    }\n  }\n  for (var i = 0; i < fullLayout.shapes.length; i++) {\n    if (fullLayout.shapes[i].visible === true) {\n      drawOne(gd, i);\n    }\n  }\n\n  // may need to resurrect this if we put text (LaTeX) in shapes\n  // return Plots.previousPromises(gd);\n}\nfunction shouldSkipEdits(gd) {\n  return !!gd._fullLayout._outlining;\n}\nfunction couldHaveActiveShape(gd) {\n  // for now keep config.editable: true as it was before shape-drawing PR\n  return !gd._context.edits.shapePosition;\n}\nfunction drawOne(gd, index) {\n  // remove the existing shape if there is one.\n  // because indices can change, we need to look in all shape layers\n  gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index=\"' + index + '\"]').remove();\n  var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);\n  var options = o.options;\n  var plotinfo = o.plotinfo;\n\n  // this shape is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n  if (!options._input || options.visible !== true) return;\n  if (options.layer !== 'below') {\n    drawShape(gd._fullLayout._shapeUpperLayer);\n  } else if (options.xref === 'paper' || options.yref === 'paper') {\n    drawShape(gd._fullLayout._shapeLowerLayer);\n  } else {\n    if (plotinfo._hadPlotinfo) {\n      var mainPlot = plotinfo.mainplotinfo || plotinfo;\n      drawShape(mainPlot.shapelayer);\n    } else {\n      // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n      // This can happen if you reference the shape to an x / y axis combination\n      // that doesn't have any data on it (and layer is below)\n      drawShape(gd._fullLayout._shapeLowerLayer);\n    }\n  }\n  function drawShape(shapeLayer) {\n    var d = getPathString(gd, options);\n    var attrs = {\n      'data-index': index,\n      'fill-rule': options.fillrule,\n      d: d\n    };\n    var opacity = options.opacity;\n    var fillColor = options.fillcolor;\n    var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n    var lineWidth = options.line.width;\n    var lineDash = options.line.dash;\n    if (!lineWidth && options.editable === true) {\n      // ensure invisible border to activate the shape\n      lineWidth = 5;\n      lineDash = 'solid';\n    }\n    var isOpen = d[d.length - 1] !== 'Z';\n    var isActiveShape = couldHaveActiveShape(gd) && options.editable && gd._fullLayout._activeShapeIndex === index;\n    if (isActiveShape) {\n      fillColor = isOpen ? 'rgba(0,0,0,0)' : gd._fullLayout.activeshape.fillcolor;\n      opacity = gd._fullLayout.activeshape.opacity;\n    }\n    var shapeGroup = shapeLayer.append('g').classed('shape-group', true).attr({\n      'data-index': index\n    });\n    var path = shapeGroup.append('path').attr(attrs).style('opacity', opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(Drawing.dashLine, lineDash, lineWidth);\n    setClipPath(shapeGroup, gd, options);\n\n    // Draw or clear the label\n    drawLabel(gd, index, options, shapeGroup);\n    var editHelpers;\n    if (isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, 'shapes', options);\n    if (isActiveShape) {\n      path.style({\n        cursor: 'move'\n      });\n      var dragOptions = {\n        element: path.node(),\n        plotinfo: plotinfo,\n        gd: gd,\n        editHelpers: editHelpers,\n        hasText: options.label.text || options.label.texttemplate,\n        isActiveShape: true // i.e. to enable controllers\n      };\n      var polygons = readPaths(d, gd);\n      // display polygons on the screen\n      displayOutlines(polygons, path, dragOptions);\n    } else {\n      if (gd._context.edits.shapePosition) {\n        setupDragElement(gd, path, options, index, shapeLayer, editHelpers);\n      } else if (options.editable === true) {\n        path.style('pointer-events', isOpen || Color.opacity(fillColor) * opacity <= 0.5 ? 'stroke' : 'all');\n      }\n    }\n    path.node().addEventListener('click', function () {\n      return activateShape(gd, path);\n    });\n  }\n}\nfunction setClipPath(shapePath, gd, shapeOptions) {\n  // note that for layer=\"below\" the clipAxes can be different from the\n  // subplot we're drawing this in. This could cause problems if the shape\n  // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n  //\n  // if axis is 'paper' or an axis with \" domain\" appended, then there is no\n  // clip axis\n  var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '').replace(/[xyz][1-9]* *domain/g, '');\n  Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n}\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {\n  var MINWIDTH = 10;\n  var MINHEIGHT = 10;\n  var xPixelSized = shapeOptions.xsizemode === 'pixel';\n  var yPixelSized = shapeOptions.ysizemode === 'pixel';\n  var isLine = shapeOptions.type === 'line';\n  var isPath = shapeOptions.type === 'path';\n  var modifyItem = editHelpers.modifyItem;\n  var x0, y0, x1, y1, xAnchor, yAnchor;\n  var n0, s0, w0, e0, optN, optS, optW, optE;\n  var pathIn;\n  var shapeGroup = d3.select(shapePath.node().parentNode);\n\n  // setup conversion functions\n  var xa = Axes.getFromId(gd, shapeOptions.xref);\n  var xRefType = Axes.getRefType(shapeOptions.xref);\n  var ya = Axes.getFromId(gd, shapeOptions.yref);\n  var yRefType = Axes.getRefType(shapeOptions.yref);\n  var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n  var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n  var p2x = helpers.getPixelToData(gd, xa, false, xRefType);\n  var p2y = helpers.getPixelToData(gd, ya, true, yRefType);\n  var sensoryElement = obtainSensoryElement();\n  var dragOptions = {\n    element: sensoryElement.node(),\n    gd: gd,\n    prepFn: startDrag,\n    doneFn: endDrag,\n    clickFn: abortDrag\n  };\n  var dragMode;\n  dragElement.init(dragOptions);\n  sensoryElement.node().onmousemove = updateDragMode;\n  function obtainSensoryElement() {\n    return isLine ? createLineDragHandles() : shapePath;\n  }\n  function createLineDragHandles() {\n    var minSensoryWidth = 10;\n    var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n    // Helper shapes group\n    // Note that by setting the `data-index` attr, it is ensured that\n    // the helper group is purged in this modules `draw` function\n    var g = shapeLayer.append('g').attr('data-index', index).attr('drag-helper', true);\n\n    // Helper path for moving\n    g.append('path').attr('d', shapePath.attr('d')).style({\n      cursor: 'move',\n      'stroke-width': sensoryWidth,\n      'stroke-opacity': '0' // ensure not visible\n    });\n\n    // Helper circles for resizing\n    var circleStyle = {\n      'fill-opacity': '0' // ensure not visible\n    };\n    var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);\n    g.append('circle').attr({\n      'data-line-point': 'start-point',\n      cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n      cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n      r: circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    g.append('circle').attr({\n      'data-line-point': 'end-point',\n      cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n      cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n      r: circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    return g;\n  }\n  function updateDragMode(evt) {\n    if (shouldSkipEdits(gd)) {\n      dragMode = null;\n      return;\n    }\n    if (isLine) {\n      if (evt.target.tagName === 'path') {\n        dragMode = 'move';\n      } else {\n        dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ? 'resize-over-start-point' : 'resize-over-end-point';\n      }\n    } else {\n      // element might not be on screen at time of setup,\n      // so obtain bounding box here\n      var dragBBox = dragOptions.element.getBoundingClientRect();\n\n      // choose 'move' or 'resize'\n      // based on initial position of cursor within the drag element\n      var w = dragBBox.right - dragBBox.left;\n      var h = dragBBox.bottom - dragBBox.top;\n      var x = evt.clientX - dragBBox.left;\n      var y = evt.clientY - dragBBox.top;\n      var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : 'move';\n      setCursor(shapePath, cursor);\n\n      // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n      dragMode = cursor.split('-')[0];\n    }\n  }\n  function startDrag(evt) {\n    if (shouldSkipEdits(gd)) return;\n\n    // setup update strings and initial values\n    if (xPixelSized) {\n      xAnchor = x2p(shapeOptions.xanchor);\n    }\n    if (yPixelSized) {\n      yAnchor = y2p(shapeOptions.yanchor);\n    }\n    if (shapeOptions.type === 'path') {\n      pathIn = shapeOptions.path;\n    } else {\n      x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n      y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n      x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n      y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n    }\n    if (x0 < x1) {\n      w0 = x0;\n      optW = 'x0';\n      e0 = x1;\n      optE = 'x1';\n    } else {\n      w0 = x1;\n      optW = 'x1';\n      e0 = x0;\n      optE = 'x0';\n    }\n\n    // For fixed size shapes take opposing direction of y-axis into account.\n    // Hint: For data sized shapes this is done by the y2p function.\n    if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {\n      n0 = y0;\n      optN = 'y0';\n      s0 = y1;\n      optS = 'y1';\n    } else {\n      n0 = y1;\n      optN = 'y1';\n      s0 = y0;\n      optS = 'y0';\n    }\n\n    // setup dragMode and the corresponding handler\n    updateDragMode(evt);\n    renderVisualCues(shapeLayer, shapeOptions);\n    deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n    dragOptions.moveFn = dragMode === 'move' ? moveShape : resizeShape;\n    dragOptions.altKey = evt.altKey;\n  }\n  function endDrag() {\n    if (shouldSkipEdits(gd)) return;\n    setCursor(shapePath);\n    removeVisualCues(shapeLayer);\n\n    // Don't rely on clipPath being activated during re-layout\n    setClipPath(shapePath, gd, shapeOptions);\n    Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n  }\n  function abortDrag() {\n    if (shouldSkipEdits(gd)) return;\n    removeVisualCues(shapeLayer);\n  }\n  function moveShape(dx, dy) {\n    if (shapeOptions.type === 'path') {\n      var noOp = function (coord) {\n        return coord;\n      };\n      var moveX = noOp;\n      var moveY = noOp;\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else {\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n        modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n        modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n      }\n    }\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n    drawLabel(gd, index, shapeOptions, shapeGroup);\n  }\n  function resizeShape(dx, dy) {\n    if (isPath) {\n      // TODO: implement path resize, don't forget to update dragMode code\n      var noOp = function (coord) {\n        return coord;\n      };\n      var moveX = noOp;\n      var moveY = noOp;\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else if (isLine) {\n      if (dragMode === 'resize-over-start-point') {\n        var newX0 = x0 + dx;\n        var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n        modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n        modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n      } else if (dragMode === 'resize-over-end-point') {\n        var newX1 = x1 + dx;\n        var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n        modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n        modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n      }\n    } else {\n      var has = function (str) {\n        return dragMode.indexOf(str) !== -1;\n      };\n      var hasN = has('n');\n      var hasS = has('s');\n      var hasW = has('w');\n      var hasE = has('e');\n      var newN = hasN ? n0 + dy : n0;\n      var newS = hasS ? s0 + dy : s0;\n      var newW = hasW ? w0 + dx : w0;\n      var newE = hasE ? e0 + dx : e0;\n      if (yPixelSized) {\n        // Do things in opposing direction for y-axis.\n        // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n        if (hasN) newN = n0 - dy;\n        if (hasS) newS = s0 - dy;\n      }\n\n      // Update shape eventually. Again, be aware of the\n      // opposing direction of the y-axis of fixed size shapes.\n      if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {\n        modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n        modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n      }\n      if (newE - newW > MINWIDTH) {\n        modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n        modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n      }\n    }\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n    drawLabel(gd, index, shapeOptions, shapeGroup);\n  }\n  function renderVisualCues(shapeLayer, shapeOptions) {\n    if (xPixelSized || yPixelSized) {\n      renderAnchor();\n    }\n    function renderAnchor() {\n      var isNotPath = shapeOptions.type !== 'path';\n\n      // d3 join with dummy data to satisfy d3 data-binding\n      var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n      // Enter\n      var strokeWidth = 1;\n      visualCues.enter().append('path').attr({\n        fill: '#fff',\n        'fill-rule': 'evenodd',\n        stroke: '#000',\n        'stroke-width': strokeWidth\n      }).classed('visual-cue', true);\n\n      // Update\n      var posX = x2p(xPixelSized ? shapeOptions.xanchor : Lib.midRange(isNotPath ? [shapeOptions.x0, shapeOptions.x1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsX)));\n      var posY = y2p(yPixelSized ? shapeOptions.yanchor : Lib.midRange(isNotPath ? [shapeOptions.y0, shapeOptions.y1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsY)));\n      posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n      posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n      if (xPixelSized && yPixelSized) {\n        var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n        visualCues.attr('d', crossPath);\n      } else if (xPixelSized) {\n        var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) + 'v18 h2 v-18 Z';\n        visualCues.attr('d', vBarPath);\n      } else {\n        var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h18 v2 h-18 Z';\n        visualCues.attr('d', hBarPath);\n      }\n    }\n  }\n  function removeVisualCues(shapeLayer) {\n    shapeLayer.selectAll('.visual-cue').remove();\n  }\n  function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n    var xref = shapeOptions.xref;\n    var yref = shapeOptions.yref;\n    var xa = Axes.getFromId(gd, xref);\n    var ya = Axes.getFromId(gd, yref);\n    var clipAxes = '';\n    if (xref !== 'paper' && !xa.autorange) clipAxes += xref;\n    if (yref !== 'paper' && !ya.autorange) clipAxes += yref;\n    Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n  }\n}\nfunction movePath(pathIn, moveX, moveY) {\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (paramNumber >= nParams) return param;\n      if (xParams[paramNumber]) param = moveX(param);else if (yParams[paramNumber]) param = moveY(param);\n      paramNumber++;\n      return param;\n    });\n    return segmentType + paramString;\n  });\n}\nfunction activateShape(gd, path) {\n  if (!couldHaveActiveShape(gd)) return;\n  var element = path.node();\n  var id = +element.getAttribute('data-index');\n  if (id >= 0) {\n    // deactivate if already active\n    if (id === gd._fullLayout._activeShapeIndex) {\n      deactivateShape(gd);\n      return;\n    }\n    gd._fullLayout._activeShapeIndex = id;\n    gd._fullLayout._deactivateShape = deactivateShape;\n    draw(gd);\n  }\n}\nfunction deactivateShape(gd) {\n  if (!couldHaveActiveShape(gd)) return;\n  var id = gd._fullLayout._activeShapeIndex;\n  if (id >= 0) {\n    clearOutlineControllers(gd);\n    delete gd._fullLayout._activeShapeIndex;\n    draw(gd);\n  }\n}\nfunction eraseActiveShape(gd) {\n  if (!couldHaveActiveShape(gd)) return;\n  clearOutlineControllers(gd);\n  var id = gd._fullLayout._activeShapeIndex;\n  var shapes = (gd.layout || {}).shapes || [];\n  if (id < shapes.length) {\n    var list = [];\n    for (var q = 0; q < shapes.length; q++) {\n      if (q !== id) {\n        list.push(shapes[q]);\n      }\n    }\n    delete gd._fullLayout._activeShapeIndex;\n    return Registry.call('_guiRelayout', gd, {\n      shapes: list\n    });\n  }\n}","map":{"version":3,"names":["d3","require","Registry","Lib","Axes","readPaths","displayOutlines","drawLabel","clearOutlineControllers","Color","Drawing","arrayEditor","dragElement","setCursor","constants","helpers","getPathString","module","exports","draw","drawOne","eraseActiveShape","gd","fullLayout","_fullLayout","_shapeUpperLayer","selectAll","remove","_shapeLowerLayer","k","_plots","shapelayer","i","shapes","length","visible","shouldSkipEdits","_outlining","couldHaveActiveShape","_context","edits","shapePosition","index","_paperdiv","o","makeShapesOptionsAndPlotinfo","options","plotinfo","_input","layer","drawShape","xref","yref","_hadPlotinfo","mainPlot","mainplotinfo","shapeLayer","d","attrs","fillrule","opacity","fillColor","fillcolor","lineColor","line","width","color","lineWidth","lineDash","dash","editable","isOpen","isActiveShape","_activeShapeIndex","activeshape","shapeGroup","append","classed","attr","path","style","call","stroke","fill","dashLine","setClipPath","editHelpers","layout","cursor","dragOptions","element","node","hasText","label","text","texttemplate","polygons","setupDragElement","addEventListener","activateShape","shapePath","shapeOptions","clipAxes","replace","setClipUrl","_uid","MINWIDTH","MINHEIGHT","xPixelSized","xsizemode","yPixelSized","ysizemode","isLine","type","isPath","modifyItem","x0","y0","x1","y1","xAnchor","yAnchor","n0","s0","w0","e0","optN","optS","optW","optE","pathIn","select","parentNode","xa","getFromId","xRefType","getRefType","ya","yRefType","x2p","getDataToPixel","y2p","p2x","getPixelToData","p2y","sensoryElement","obtainSensoryElement","prepFn","startDrag","doneFn","endDrag","clickFn","abortDrag","dragMode","init","onmousemove","updateDragMode","createLineDragHandles","minSensoryWidth","sensoryWidth","Math","max","g","circleStyle","circleRadius","cx","xanchor","cy","yanchor","r","evt","target","tagName","attributes","value","dragBBox","getBoundingClientRect","w","right","left","h","bottom","top","x","clientX","y","clientY","shiftKey","getCursor","split","renderVisualCues","deactivateClipPathTemporarily","moveFn","moveShape","resizeShape","altKey","removeVisualCues","getUpdateObj","dx","dy","noOp","coord","moveX","moveY","encodeDate","movePath","newX0","newY0","newX1","newY1","has","str","indexOf","hasN","hasS","hasW","hasE","newN","newS","newW","newE","renderAnchor","isNotPath","visualCues","data","strokeWidth","enter","posX","midRange","extractPathCoords","paramIsX","posY","paramIsY","roundPositionForSharpStrokeRendering","crossPath","vBarPath","hBarPath","autorange","segmentRE","segment","paramNumber","segmentType","charAt","xParams","yParams","nParams","numParams","paramString","substr","paramRE","param","id","getAttribute","deactivateShape","_deactivateShape","list","q","push"],"sources":["C:/Users/Magdiel/node_modules/plotly.js/src/components/shapes/draw.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar readPaths = require('./draw_newshape/helpers').readPaths;\nvar displayOutlines = require('./display_outlines');\nvar drawLabel = require('./display_labels');\n\nvar clearOutlineControllers = require('./handle_outline').clearOutlineControllers;\n\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nvar getPathString = helpers.getPathString;\n\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne,\n    eraseActiveShape: eraseActiveShape,\n    drawLabel: drawLabel,\n};\n\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n    fullLayout._shapeUpperLayer.selectAll('path').remove();\n    fullLayout._shapeLowerLayer.selectAll('path').remove();\n    fullLayout._shapeUpperLayer.selectAll('text').remove();\n    fullLayout._shapeLowerLayer.selectAll('text').remove();\n\n    for(var k in fullLayout._plots) {\n        var shapelayer = fullLayout._plots[k].shapelayer;\n        if(shapelayer) {\n            shapelayer.selectAll('path').remove();\n            shapelayer.selectAll('text').remove();\n        }\n    }\n\n    for(var i = 0; i < fullLayout.shapes.length; i++) {\n        if(fullLayout.shapes[i].visible === true) {\n            drawOne(gd, i);\n        }\n    }\n\n    // may need to resurrect this if we put text (LaTeX) in shapes\n    // return Plots.previousPromises(gd);\n}\n\nfunction shouldSkipEdits(gd) {\n    return !!gd._fullLayout._outlining;\n}\n\nfunction couldHaveActiveShape(gd) {\n    // for now keep config.editable: true as it was before shape-drawing PR\n    return !gd._context.edits.shapePosition;\n}\n\nfunction drawOne(gd, index) {\n    // remove the existing shape if there is one.\n    // because indices can change, we need to look in all shape layers\n    gd._fullLayout._paperdiv\n        .selectAll('.shapelayer [data-index=\"' + index + '\"]')\n        .remove();\n\n    var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);\n    var options = o.options;\n    var plotinfo = o.plotinfo;\n\n    // this shape is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible !== true) return;\n\n    if(options.layer !== 'below') {\n        drawShape(gd._fullLayout._shapeUpperLayer);\n    } else if(options.xref === 'paper' || options.yref === 'paper') {\n        drawShape(gd._fullLayout._shapeLowerLayer);\n    } else {\n        if(plotinfo._hadPlotinfo) {\n            var mainPlot = plotinfo.mainplotinfo || plotinfo;\n            drawShape(mainPlot.shapelayer);\n        } else {\n            // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n            // This can happen if you reference the shape to an x / y axis combination\n            // that doesn't have any data on it (and layer is below)\n            drawShape(gd._fullLayout._shapeLowerLayer);\n        }\n    }\n\n    function drawShape(shapeLayer) {\n        var d = getPathString(gd, options);\n        var attrs = {\n            'data-index': index,\n            'fill-rule': options.fillrule,\n            d: d\n        };\n\n        var opacity = options.opacity;\n        var fillColor = options.fillcolor;\n        var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n        var lineWidth = options.line.width;\n        var lineDash = options.line.dash;\n        if(!lineWidth && options.editable === true) {\n            // ensure invisible border to activate the shape\n            lineWidth = 5;\n            lineDash = 'solid';\n        }\n\n        var isOpen = d[d.length - 1] !== 'Z';\n\n        var isActiveShape = couldHaveActiveShape(gd) &&\n            options.editable && gd._fullLayout._activeShapeIndex === index;\n\n        if(isActiveShape) {\n            fillColor = isOpen ? 'rgba(0,0,0,0)' :\n                gd._fullLayout.activeshape.fillcolor;\n\n            opacity = gd._fullLayout.activeshape.opacity;\n        }\n\n        var shapeGroup = shapeLayer.append('g')\n            .classed('shape-group', true)\n            .attr({ 'data-index': index });\n\n        var path = shapeGroup.append('path')\n            .attr(attrs)\n            .style('opacity', opacity)\n            .call(Color.stroke, lineColor)\n            .call(Color.fill, fillColor)\n            .call(Drawing.dashLine, lineDash, lineWidth);\n\n        setClipPath(shapeGroup, gd, options);\n\n        // Draw or clear the label\n        drawLabel(gd, index, options, shapeGroup);\n\n        var editHelpers;\n        if(isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, 'shapes', options);\n\n        if(isActiveShape) {\n            path.style({\n                cursor: 'move',\n            });\n\n            var dragOptions = {\n                element: path.node(),\n                plotinfo: plotinfo,\n                gd: gd,\n                editHelpers: editHelpers,\n                hasText: options.label.text || options.label.texttemplate,\n                isActiveShape: true // i.e. to enable controllers\n            };\n\n            var polygons = readPaths(d, gd);\n            // display polygons on the screen\n            displayOutlines(polygons, path, dragOptions);\n        } else {\n            if(gd._context.edits.shapePosition) {\n                setupDragElement(gd, path, options, index, shapeLayer, editHelpers);\n            } else if(options.editable === true) {\n                path.style('pointer-events',\n                    (isOpen || Color.opacity(fillColor) * opacity <= 0.5) ? 'stroke' : 'all'\n                );\n            }\n        }\n        path.node().addEventListener('click', function() { return activateShape(gd, path); });\n    }\n}\n\nfunction setClipPath(shapePath, gd, shapeOptions) {\n    // note that for layer=\"below\" the clipAxes can be different from the\n    // subplot we're drawing this in. This could cause problems if the shape\n    // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n    //\n    // if axis is 'paper' or an axis with \" domain\" appended, then there is no\n    // clip axis\n    var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '').replace(/[xyz][1-9]* *domain/g, '');\n\n    Drawing.setClipUrl(\n        shapePath,\n        clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n        gd\n    );\n}\n\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {\n    var MINWIDTH = 10;\n    var MINHEIGHT = 10;\n\n    var xPixelSized = shapeOptions.xsizemode === 'pixel';\n    var yPixelSized = shapeOptions.ysizemode === 'pixel';\n    var isLine = shapeOptions.type === 'line';\n    var isPath = shapeOptions.type === 'path';\n\n    var modifyItem = editHelpers.modifyItem;\n\n    var x0, y0, x1, y1, xAnchor, yAnchor;\n    var n0, s0, w0, e0, optN, optS, optW, optE;\n    var pathIn;\n\n    var shapeGroup = d3.select(shapePath.node().parentNode);\n\n    // setup conversion functions\n    var xa = Axes.getFromId(gd, shapeOptions.xref);\n    var xRefType = Axes.getRefType(shapeOptions.xref);\n    var ya = Axes.getFromId(gd, shapeOptions.yref);\n    var yRefType = Axes.getRefType(shapeOptions.yref);\n    var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n    var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n    var p2x = helpers.getPixelToData(gd, xa, false, xRefType);\n    var p2y = helpers.getPixelToData(gd, ya, true, yRefType);\n\n    var sensoryElement = obtainSensoryElement();\n    var dragOptions = {\n        element: sensoryElement.node(),\n        gd: gd,\n        prepFn: startDrag,\n        doneFn: endDrag,\n        clickFn: abortDrag\n    };\n    var dragMode;\n\n    dragElement.init(dragOptions);\n\n    sensoryElement.node().onmousemove = updateDragMode;\n\n    function obtainSensoryElement() {\n        return isLine ? createLineDragHandles() : shapePath;\n    }\n\n    function createLineDragHandles() {\n        var minSensoryWidth = 10;\n        var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n        // Helper shapes group\n        // Note that by setting the `data-index` attr, it is ensured that\n        // the helper group is purged in this modules `draw` function\n        var g = shapeLayer.append('g')\n            .attr('data-index', index)\n            .attr('drag-helper', true);\n\n        // Helper path for moving\n        g.append('path')\n          .attr('d', shapePath.attr('d'))\n          .style({\n              cursor: 'move',\n              'stroke-width': sensoryWidth,\n              'stroke-opacity': '0' // ensure not visible\n          });\n\n        // Helper circles for resizing\n        var circleStyle = {\n            'fill-opacity': '0' // ensure not visible\n        };\n        var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'start-point',\n              cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n              cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n              r: circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'end-point',\n              cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n              cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n              r: circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        return g;\n    }\n\n    function updateDragMode(evt) {\n        if(shouldSkipEdits(gd)) {\n            dragMode = null;\n            return;\n        }\n\n        if(isLine) {\n            if(evt.target.tagName === 'path') {\n                dragMode = 'move';\n            } else {\n                dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ?\n                  'resize-over-start-point' : 'resize-over-end-point';\n            }\n        } else {\n            // element might not be on screen at time of setup,\n            // so obtain bounding box here\n            var dragBBox = dragOptions.element.getBoundingClientRect();\n\n            // choose 'move' or 'resize'\n            // based on initial position of cursor within the drag element\n            var w = dragBBox.right - dragBBox.left;\n            var h = dragBBox.bottom - dragBBox.top;\n            var x = evt.clientX - dragBBox.left;\n            var y = evt.clientY - dragBBox.top;\n            var cursor = (!isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey) ?\n                dragElement.getCursor(x / w, 1 - y / h) :\n                'move';\n\n            setCursor(shapePath, cursor);\n\n            // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n            dragMode = cursor.split('-')[0];\n        }\n    }\n\n    function startDrag(evt) {\n        if(shouldSkipEdits(gd)) return;\n\n        // setup update strings and initial values\n        if(xPixelSized) {\n            xAnchor = x2p(shapeOptions.xanchor);\n        }\n        if(yPixelSized) {\n            yAnchor = y2p(shapeOptions.yanchor);\n        }\n\n        if(shapeOptions.type === 'path') {\n            pathIn = shapeOptions.path;\n        } else {\n            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n        }\n\n        if(x0 < x1) {\n            w0 = x0;\n            optW = 'x0';\n            e0 = x1;\n            optE = 'x1';\n        } else {\n            w0 = x1;\n            optW = 'x1';\n            e0 = x0;\n            optE = 'x0';\n        }\n\n        // For fixed size shapes take opposing direction of y-axis into account.\n        // Hint: For data sized shapes this is done by the y2p function.\n        if((!yPixelSized && y0 < y1) || (yPixelSized && y0 > y1)) {\n            n0 = y0;\n            optN = 'y0';\n            s0 = y1;\n            optS = 'y1';\n        } else {\n            n0 = y1;\n            optN = 'y1';\n            s0 = y0;\n            optS = 'y0';\n        }\n\n        // setup dragMode and the corresponding handler\n        updateDragMode(evt);\n        renderVisualCues(shapeLayer, shapeOptions);\n        deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n        dragOptions.moveFn = (dragMode === 'move') ? moveShape : resizeShape;\n        dragOptions.altKey = evt.altKey;\n    }\n\n    function endDrag() {\n        if(shouldSkipEdits(gd)) return;\n\n        setCursor(shapePath);\n        removeVisualCues(shapeLayer);\n\n        // Don't rely on clipPath being activated during re-layout\n        setClipPath(shapePath, gd, shapeOptions);\n        Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n    }\n\n    function abortDrag() {\n        if(shouldSkipEdits(gd)) return;\n\n        removeVisualCues(shapeLayer);\n    }\n\n    function moveShape(dx, dy) {\n        if(shapeOptions.type === 'path') {\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        } else {\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n                modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n                modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n        drawLabel(gd, index, shapeOptions, shapeGroup);\n    }\n\n    function resizeShape(dx, dy) {\n        if(isPath) {\n            // TODO: implement path resize, don't forget to update dragMode code\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        } else if(isLine) {\n            if(dragMode === 'resize-over-start-point') {\n                var newX0 = x0 + dx;\n                var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n                modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n                modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n            } else if(dragMode === 'resize-over-end-point') {\n                var newX1 = x1 + dx;\n                var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n                modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n                modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n            }\n        } else {\n            var has = function(str) { return dragMode.indexOf(str) !== -1; };\n            var hasN = has('n');\n            var hasS = has('s');\n            var hasW = has('w');\n            var hasE = has('e');\n\n            var newN = hasN ? n0 + dy : n0;\n            var newS = hasS ? s0 + dy : s0;\n            var newW = hasW ? w0 + dx : w0;\n            var newE = hasE ? e0 + dx : e0;\n\n            if(yPixelSized) {\n                // Do things in opposing direction for y-axis.\n                // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n                if(hasN) newN = n0 - dy;\n                if(hasS) newS = s0 - dy;\n            }\n\n            // Update shape eventually. Again, be aware of the\n            // opposing direction of the y-axis of fixed size shapes.\n            if(\n                (!yPixelSized && newS - newN > MINHEIGHT) ||\n                (yPixelSized && newN - newS > MINHEIGHT)\n            ) {\n                modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n                modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n            }\n            if(newE - newW > MINWIDTH) {\n                modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n                modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n        drawLabel(gd, index, shapeOptions, shapeGroup);\n    }\n\n    function renderVisualCues(shapeLayer, shapeOptions) {\n        if(xPixelSized || yPixelSized) {\n            renderAnchor();\n        }\n\n        function renderAnchor() {\n            var isNotPath = shapeOptions.type !== 'path';\n\n            // d3 join with dummy data to satisfy d3 data-binding\n            var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n            // Enter\n            var strokeWidth = 1;\n            visualCues.enter()\n              .append('path')\n              .attr({\n                  fill: '#fff',\n                  'fill-rule': 'evenodd',\n                  stroke: '#000',\n                  'stroke-width': strokeWidth\n              })\n              .classed('visual-cue', true);\n\n            // Update\n            var posX = x2p(\n              xPixelSized ?\n                shapeOptions.xanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.x0, shapeOptions.x1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsX))\n            );\n            var posY = y2p(\n              yPixelSized ?\n                shapeOptions.yanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.y0, shapeOptions.y1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsY))\n            );\n\n            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n\n            if(xPixelSized && yPixelSized) {\n                var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n                visualCues.attr('d', crossPath);\n            } else if(xPixelSized) {\n                var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) +\n                  'v18 h2 v-18 Z';\n                visualCues.attr('d', vBarPath);\n            } else {\n                var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h18 v2 h-18 Z';\n                visualCues.attr('d', hBarPath);\n            }\n        }\n    }\n\n    function removeVisualCues(shapeLayer) {\n        shapeLayer.selectAll('.visual-cue').remove();\n    }\n\n    function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n        var xref = shapeOptions.xref;\n        var yref = shapeOptions.yref;\n        var xa = Axes.getFromId(gd, xref);\n        var ya = Axes.getFromId(gd, yref);\n\n        var clipAxes = '';\n        if(xref !== 'paper' && !xa.autorange) clipAxes += xref;\n        if(yref !== 'paper' && !ya.autorange) clipAxes += yref;\n\n        Drawing.setClipUrl(\n            shapePath,\n            clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n            gd\n        );\n    }\n}\n\nfunction movePath(pathIn, moveX, moveY) {\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(paramNumber >= nParams) return param;\n\n            if(xParams[paramNumber]) param = moveX(param);\n            else if(yParams[paramNumber]) param = moveY(param);\n\n            paramNumber++;\n\n            return param;\n        });\n\n        return segmentType + paramString;\n    });\n}\n\nfunction activateShape(gd, path) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    var element = path.node();\n    var id = +element.getAttribute('data-index');\n    if(id >= 0) {\n        // deactivate if already active\n        if(id === gd._fullLayout._activeShapeIndex) {\n            deactivateShape(gd);\n            return;\n        }\n\n        gd._fullLayout._activeShapeIndex = id;\n        gd._fullLayout._deactivateShape = deactivateShape;\n        draw(gd);\n    }\n}\n\nfunction deactivateShape(gd) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    var id = gd._fullLayout._activeShapeIndex;\n    if(id >= 0) {\n        clearOutlineControllers(gd);\n        delete gd._fullLayout._activeShapeIndex;\n        draw(gd);\n    }\n}\n\nfunction eraseActiveShape(gd) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    clearOutlineControllers(gd);\n\n    var id = gd._fullLayout._activeShapeIndex;\n    var shapes = (gd.layout || {}).shapes || [];\n    if(id < shapes.length) {\n        var list = [];\n        for(var q = 0; q < shapes.length; q++) {\n            if(q !== id) {\n                list.push(shapes[q]);\n            }\n        }\n\n        delete gd._fullLayout._activeShapeIndex;\n\n        return Registry.call('_guiRelayout', gd, {\n            shapes: list\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}