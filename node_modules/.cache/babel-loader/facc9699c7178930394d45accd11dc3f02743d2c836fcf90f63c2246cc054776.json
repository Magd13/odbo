{"ast":null,"code":"'use strict';\n\nconst rgba = require('color-normalize');\nconst getBounds = require('array-bounds');\nconst extend = require('object-assign');\nconst glslify = require('glslify');\nconst pick = require('pick-by-alias');\nconst flatten = require('flatten-vertex-data');\nconst triangulate = require('earcut');\nconst normalize = require('array-normalize');\nconst {\n  float32,\n  fract32\n} = require('to-float32');\nconst WeakMap = require('es6-weak-map');\nconst parseRect = require('parse-rect');\nconst findIndex = require('array-find-index');\nmodule.exports = Line2D;\n\n/** @constructor */\nfunction Line2D(regl, options) {\n  if (!(this instanceof Line2D)) return new Line2D(regl, options);\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n  }\n  if (options.length) options.positions = options;\n  regl = options.regl;\n  if (!regl.hasExtension('ANGLE_instanced_arrays')) {\n    throw Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n  }\n\n  // persistent variables\n  this.gl = regl._gl;\n  this.regl = regl;\n\n  // list of options for lines\n  this.passes = [];\n\n  // cached shaders instance\n  this.shaders = Line2D.shaders.has(regl) ? Line2D.shaders.get(regl) : Line2D.shaders.set(regl, Line2D.createShaders(regl)).get(regl);\n\n  // init defaults\n  this.update(options);\n}\nLine2D.dashMult = 2;\nLine2D.maxPatternLength = 256;\nLine2D.precisionThreshold = 3e6;\nLine2D.maxPoints = 1e4;\nLine2D.maxLines = 2048;\n\n// cache of created draw calls per-regl instance\nLine2D.shaders = new WeakMap();\n\n// create static shaders once\nLine2D.createShaders = function (regl) {\n  let offsetBuffer = regl.buffer({\n    usage: 'static',\n    type: 'float',\n    data: [0, 1, 0, 0, 1, 1, 1, 0]\n  });\n  let shaderOptions = {\n    primitive: 'triangle strip',\n    instances: regl.prop('count'),\n    count: 4,\n    offset: 0,\n    uniforms: {\n      miterMode: (ctx, prop) => prop.join === 'round' ? 2 : 1,\n      miterLimit: regl.prop('miterLimit'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      thickness: regl.prop('thickness'),\n      dashTexture: regl.prop('dashTexture'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      dashLength: regl.prop('dashLength'),\n      viewport: (c, p) => [p.viewport.x, p.viewport.y, c.viewportWidth, c.viewportHeight],\n      depth: regl.prop('depth')\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 0],\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    depth: {\n      enable: (c, p) => {\n        return !p.overlay;\n      }\n    },\n    stencil: {\n      enable: false\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport')\n  };\n\n  // simplified rectangular line shader\n  let drawRectLine = regl(extend({\n    vert: glslify('./rect-vert.glsl'),\n    frag: glslify('./rect-frag.glsl'),\n    attributes: {\n      // if point is at the end of segment\n      lineEnd: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 0\n      },\n      // if point is at the top of segment\n      lineTop: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 4\n      },\n      // beginning of line coordinate\n      aCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      // end of line coordinate\n      bCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      aCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      bCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      color: {\n        buffer: regl.prop('colorBuffer'),\n        stride: 4,\n        offset: 0,\n        divisor: 1\n      }\n    }\n  }, shaderOptions));\n\n  // create regl draw\n  let drawMiterLine;\n  try {\n    drawMiterLine = regl(extend({\n      // culling removes polygon creasing\n      cull: {\n        enable: true,\n        face: 'back'\n      },\n      vert: glslify('./miter-vert.glsl'),\n      frag: glslify('./miter-frag.glsl'),\n      attributes: {\n        // is line end\n        lineEnd: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 0\n        },\n        // is line top\n        lineTop: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 4\n        },\n        // left color\n        aColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 0,\n          divisor: 1\n        },\n        // right color\n        bColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 4,\n          divisor: 1\n        },\n        prevCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 0,\n          divisor: 1\n        },\n        aCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 8,\n          divisor: 1\n        },\n        bCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 16,\n          divisor: 1\n        },\n        nextCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 24,\n          divisor: 1\n        }\n      }\n    }, shaderOptions));\n  } catch (e) {\n    // IE/bad Webkit fallback\n    drawMiterLine = drawRectLine;\n  }\n\n  // fill shader\n  let drawFill = regl({\n    primitive: 'triangle',\n    elements: (ctx, prop) => prop.triangles,\n    offset: 0,\n    vert: glslify('./fill-vert.glsl'),\n    frag: glslify('./fill-frag.glsl'),\n    uniforms: {\n      scale: regl.prop('scale'),\n      color: regl.prop('fill'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      viewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]\n    },\n    attributes: {\n      position: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8\n      },\n      positionFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8\n      }\n    },\n    blend: shaderOptions.blend,\n    depth: {\n      enable: false\n    },\n    scissor: shaderOptions.scissor,\n    stencil: shaderOptions.stencil,\n    viewport: shaderOptions.viewport\n  });\n  return {\n    fill: drawFill,\n    rect: drawRectLine,\n    miter: drawMiterLine\n  };\n};\n\n// used to for new lines instances\nLine2D.defaults = {\n  dashes: null,\n  join: 'miter',\n  miterLimit: 1,\n  thickness: 10,\n  cap: 'square',\n  color: 'black',\n  opacity: 1,\n  overlay: false,\n  viewport: null,\n  range: null,\n  close: false,\n  fill: null\n};\nLine2D.prototype.render = function (...args) {\n  if (args.length) {\n    this.update(...args);\n  }\n  this.draw();\n};\nLine2D.prototype.draw = function (...args) {\n  // render multiple polylines via regl batch\n  (args.length ? args : this.passes).forEach((s, i) => {\n    // render array pass as a list of passes\n    if (s && Array.isArray(s)) return this.draw(...s);\n    if (typeof s === 'number') s = this.passes[s];\n    if (!(s && s.count > 1 && s.opacity)) return;\n    this.regl._refresh();\n    if (s.fill && s.triangles && s.triangles.length > 2) {\n      this.shaders.fill(s);\n    }\n    if (!s.thickness) return;\n\n    // high scale is only available for rect mode with precision\n    if (s.scale[0] * s.viewport.width > Line2D.precisionThreshold || s.scale[1] * s.viewport.height > Line2D.precisionThreshold) {\n      this.shaders.rect(s);\n    }\n\n    // thin this.passes or too many points are rendered as simplified rect shader\n    else if (s.join === 'rect' || !s.join && (s.thickness <= 2 || s.count >= Line2D.maxPoints)) {\n      this.shaders.rect(s);\n    } else {\n      this.shaders.miter(s);\n    }\n  });\n  return this;\n};\nLine2D.prototype.update = function (options) {\n  if (!options) return;\n  if (options.length != null) {\n    if (typeof options[0] === 'number') options = [{\n      positions: options\n    }];\n  }\n\n  // make options a batch\n  else if (!Array.isArray(options)) options = [options];\n  let {\n    regl,\n    gl\n  } = this;\n\n  // process per-line settings\n  options.forEach((o, i) => {\n    let state = this.passes[i];\n    if (o === undefined) return;\n\n    // null-argument removes pass\n    if (o === null) {\n      this.passes[i] = null;\n      return;\n    }\n    if (typeof o[0] === 'number') o = {\n      positions: o\n    };\n\n    // handle aliases\n    o = pick(o, {\n      positions: 'positions points data coords',\n      thickness: 'thickness lineWidth lineWidths line-width linewidth width stroke-width strokewidth strokeWidth',\n      join: 'lineJoin linejoin join type mode',\n      miterLimit: 'miterlimit miterLimit',\n      dashes: 'dash dashes dasharray dash-array dashArray',\n      color: 'color colour stroke colors colours stroke-color strokeColor',\n      fill: 'fill fill-color fillColor',\n      opacity: 'alpha opacity',\n      overlay: 'overlay crease overlap intersect',\n      close: 'closed close closed-path closePath',\n      range: 'range dataBox',\n      viewport: 'viewport viewBox',\n      hole: 'holes hole hollow',\n      splitNull: 'splitNull'\n    });\n\n    // init state\n    if (!state) {\n      this.passes[i] = state = {\n        id: i,\n        scale: null,\n        scaleFract: null,\n        translate: null,\n        translateFract: null,\n        count: 0,\n        hole: [],\n        depth: 0,\n        dashLength: 1,\n        dashTexture: regl.texture({\n          channels: 1,\n          data: new Uint8Array([255]),\n          width: 1,\n          height: 1,\n          mag: 'linear',\n          min: 'linear'\n        }),\n        colorBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'uint8',\n          data: new Uint8Array()\n        }),\n        positionBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        }),\n        positionFractBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        })\n      };\n      o = extend({}, Line2D.defaults, o);\n    }\n    if (o.thickness != null) state.thickness = parseFloat(o.thickness);\n    if (o.opacity != null) state.opacity = parseFloat(o.opacity);\n    if (o.miterLimit != null) state.miterLimit = parseFloat(o.miterLimit);\n    if (o.overlay != null) {\n      state.overlay = !!o.overlay;\n      if (i < Line2D.maxLines) {\n        state.depth = 2 * (Line2D.maxLines - 1 - i % Line2D.maxLines) / Line2D.maxLines - 1.;\n      }\n    }\n    if (o.join != null) state.join = o.join;\n    if (o.hole != null) state.hole = o.hole;\n    if (o.fill != null) state.fill = !o.fill ? null : rgba(o.fill, 'uint8');\n    if (o.viewport != null) state.viewport = parseRect(o.viewport);\n    if (!state.viewport) {\n      state.viewport = parseRect([gl.drawingBufferWidth, gl.drawingBufferHeight]);\n    }\n    if (o.close != null) state.close = o.close;\n\n    // reset positions\n    if (o.positions === null) o.positions = [];\n    if (o.positions) {\n      let positions, count;\n\n      // if positions are an object with x/y\n      if (o.positions.x && o.positions.y) {\n        let xPos = o.positions.x;\n        let yPos = o.positions.y;\n        count = state.count = Math.max(xPos.length, yPos.length);\n        positions = new Float64Array(count * 2);\n        for (let i = 0; i < count; i++) {\n          positions[i * 2] = xPos[i];\n          positions[i * 2 + 1] = yPos[i];\n        }\n      } else {\n        positions = flatten(o.positions, 'float64');\n        count = state.count = Math.floor(positions.length / 2);\n      }\n      let bounds = state.bounds = getBounds(positions, 2);\n\n      // create fill positions\n      // FIXME: fill positions can be set only along with positions\n      if (state.fill) {\n        let pos = [];\n\n        // filter bad vertices and remap triangles to ensure shape\n        let ids = {};\n        let lastId = 0;\n        for (let i = 0, ptr = 0, l = state.count; i < l; i++) {\n          let x = positions[i * 2];\n          let y = positions[i * 2 + 1];\n          if (isNaN(x) || isNaN(y) || x == null || y == null) {\n            x = positions[lastId * 2];\n            y = positions[lastId * 2 + 1];\n            ids[i] = lastId;\n          } else {\n            lastId = i;\n          }\n          pos[ptr++] = x;\n          pos[ptr++] = y;\n        }\n\n        // split the input into multiple polygon at Null/NaN\n        if (o.splitNull) {\n          // use \"ids\" to track the boundary of segment\n          // the keys in \"ids\" is the end boundary of a segment, or split point\n\n          // make sure there is at least one segment\n          if (!(state.count - 1 in ids)) ids[state.count] = state.count - 1;\n          let splits = Object.keys(ids).map(Number).sort((a, b) => a - b);\n          let split_triangles = [];\n          let base = 0;\n\n          // do not split holes\n          let hole_base = state.hole != null ? state.hole[0] : null;\n          if (hole_base != null) {\n            let last_id = findIndex(splits, e => e >= hole_base);\n            splits = splits.slice(0, last_id);\n            splits.push(hole_base);\n          }\n          for (let i = 0; i < splits.length; i++) {\n            // create temporary pos array with only one segment and all the holes\n            let seg_pos = pos.slice(base * 2, splits[i] * 2).concat(hole_base ? pos.slice(hole_base * 2) : []);\n            let hole = (state.hole || []).map(e => e - hole_base + (splits[i] - base));\n            let triangles = triangulate(seg_pos, hole);\n            // map triangle index back to the original pos buffer\n            triangles = triangles.map(e => e + base + (e + base < splits[i] ? 0 : hole_base - splits[i]));\n            split_triangles.push(...triangles);\n\n            // skip split point\n            base = splits[i] + 1;\n          }\n          for (let i = 0, l = split_triangles.length; i < l; i++) {\n            if (ids[split_triangles[i]] != null) split_triangles[i] = ids[split_triangles[i]];\n          }\n          state.triangles = split_triangles;\n        } else {\n          // treat the wholw input as a single polygon\n          let triangles = triangulate(pos, state.hole || []);\n          for (let i = 0, l = triangles.length; i < l; i++) {\n            if (ids[triangles[i]] != null) triangles[i] = ids[triangles[i]];\n          }\n          state.triangles = triangles;\n        }\n      }\n\n      // update position buffers\n      let npos = new Float64Array(positions);\n      normalize(npos, 2, bounds);\n      let positionData = new Float64Array(count * 2 + 6);\n\n      // rotate first segment join\n      if (state.close) {\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[0] = npos[count * 2 - 4];\n          positionData[1] = npos[count * 2 - 3];\n        } else {\n          positionData[0] = npos[count * 2 - 2];\n          positionData[1] = npos[count * 2 - 1];\n        }\n      } else {\n        positionData[0] = npos[0];\n        positionData[1] = npos[1];\n      }\n      positionData.set(npos, 2);\n\n      // add last segment\n      if (state.close) {\n        // ignore coinciding start/end\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[count * 2 + 2] = npos[2];\n          positionData[count * 2 + 3] = npos[3];\n          state.count -= 1;\n        } else {\n          positionData[count * 2 + 2] = npos[0];\n          positionData[count * 2 + 3] = npos[1];\n          positionData[count * 2 + 4] = npos[2];\n          positionData[count * 2 + 5] = npos[3];\n        }\n      }\n      // add stub\n      else {\n        positionData[count * 2 + 2] = npos[count * 2 - 2];\n        positionData[count * 2 + 3] = npos[count * 2 - 1];\n        positionData[count * 2 + 4] = npos[count * 2 - 2];\n        positionData[count * 2 + 5] = npos[count * 2 - 1];\n      }\n      var float_data = float32(positionData);\n      state.positionBuffer(float_data);\n      var frac_data = fract32(positionData, float_data);\n      state.positionFractBuffer(frac_data);\n    }\n    if (o.range) {\n      state.range = o.range;\n    } else if (!state.range) {\n      state.range = state.bounds;\n    }\n    if ((o.range || o.positions) && state.count) {\n      let bounds = state.bounds;\n      let boundsW = bounds[2] - bounds[0],\n        boundsH = bounds[3] - bounds[1];\n      let rangeW = state.range[2] - state.range[0],\n        rangeH = state.range[3] - state.range[1];\n      state.scale = [boundsW / rangeW, boundsH / rangeH];\n      state.translate = [-state.range[0] / rangeW + bounds[0] / rangeW || 0, -state.range[1] / rangeH + bounds[1] / rangeH || 0];\n      state.scaleFract = fract32(state.scale);\n      state.translateFract = fract32(state.translate);\n    }\n    if (o.dashes) {\n      let dashLength = 0.,\n        dashData;\n      if (!o.dashes || o.dashes.length < 2) {\n        dashLength = 1.;\n        dashData = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]);\n      } else {\n        dashLength = 0.;\n        for (let i = 0; i < o.dashes.length; ++i) {\n          dashLength += o.dashes[i];\n        }\n        dashData = new Uint8Array(dashLength * Line2D.dashMult);\n        let ptr = 0;\n        let fillColor = 255;\n\n        // repeat texture two times to provide smooth 0-step\n        for (let k = 0; k < 2; k++) {\n          for (let i = 0; i < o.dashes.length; ++i) {\n            for (let j = 0, l = o.dashes[i] * Line2D.dashMult * .5; j < l; ++j) {\n              dashData[ptr++] = fillColor;\n            }\n            fillColor ^= 255;\n          }\n        }\n      }\n      state.dashLength = dashLength;\n      state.dashTexture({\n        channels: 1,\n        data: dashData,\n        width: dashData.length,\n        height: 1,\n        mag: 'linear',\n        min: 'linear'\n      }, 0, 0);\n    }\n    if (o.color) {\n      let count = state.count;\n      let colors = o.color;\n      if (!colors) colors = 'transparent';\n      let colorData = new Uint8Array(count * 4 + 4);\n\n      // convert colors to typed arrays\n      if (!Array.isArray(colors) || typeof colors[0] === 'number') {\n        let c = rgba(colors, 'uint8');\n        for (let i = 0; i < count + 1; i++) {\n          colorData.set(c, i * 4);\n        }\n      } else {\n        for (let i = 0; i < count; i++) {\n          let c = rgba(colors[i], 'uint8');\n          colorData.set(c, i * 4);\n        }\n        colorData.set(rgba(colors[0], 'uint8'), count * 4);\n      }\n      state.colorBuffer({\n        usage: 'dynamic',\n        type: 'uint8',\n        data: colorData\n      });\n    }\n  });\n\n  // remove unmentioned passes\n  if (options.length < this.passes.length) {\n    for (let i = options.length; i < this.passes.length; i++) {\n      let pass = this.passes[i];\n      if (!pass) continue;\n      pass.colorBuffer.destroy();\n      pass.positionBuffer.destroy();\n      pass.dashTexture.destroy();\n    }\n    this.passes.length = options.length;\n  }\n\n  // remove null items\n  let passes = [];\n  for (let i = 0; i < this.passes.length; i++) {\n    if (this.passes[i] !== null) passes.push(this.passes[i]);\n  }\n  this.passes = passes;\n  return this;\n};\nLine2D.prototype.destroy = function () {\n  this.passes.forEach(pass => {\n    pass.colorBuffer.destroy();\n    pass.positionBuffer.destroy();\n    pass.dashTexture.destroy();\n  });\n  this.passes.length = 0;\n  return this;\n};","map":{"version":3,"names":["rgba","require","getBounds","extend","glslify","pick","flatten","triangulate","normalize","float32","fract32","WeakMap","parseRect","findIndex","module","exports","Line2D","regl","options","length","positions","hasExtension","Error","gl","_gl","passes","shaders","has","get","set","createShaders","update","dashMult","maxPatternLength","precisionThreshold","maxPoints","maxLines","offsetBuffer","buffer","usage","type","data","shaderOptions","primitive","instances","prop","count","offset","uniforms","miterMode","ctx","join","miterLimit","scale","scaleFract","translateFract","translate","thickness","dashTexture","opacity","pixelRatio","context","id","dashLength","viewport","c","p","x","y","viewportWidth","viewportHeight","depth","blend","enable","color","equation","rgb","alpha","func","srcRGB","dstRGB","srcAlpha","dstAlpha","overlay","stencil","scissor","box","drawRectLine","vert","frag","attributes","lineEnd","divisor","stride","lineTop","aCoord","bCoord","aCoordFract","bCoordFract","drawMiterLine","cull","face","aColor","bColor","prevCoord","nextCoord","e","drawFill","elements","triangles","position","positionFract","fill","rect","miter","defaults","dashes","cap","range","close","prototype","render","args","draw","forEach","s","i","Array","isArray","_refresh","width","height","o","state","undefined","hole","splitNull","texture","channels","Uint8Array","mag","min","colorBuffer","positionBuffer","positionFractBuffer","parseFloat","drawingBufferWidth","drawingBufferHeight","xPos","yPos","Math","max","Float64Array","floor","bounds","pos","ids","lastId","ptr","l","isNaN","splits","Object","keys","map","Number","sort","a","b","split_triangles","base","hole_base","last_id","slice","push","seg_pos","concat","npos","positionData","float_data","frac_data","boundsW","boundsH","rangeW","rangeH","dashData","fillColor","k","j","colors","colorData","pass","destroy"],"sources":["C:/Users/Magdiel/node_modules/regl-line2d/index.js"],"sourcesContent":["'use strict'\n\n\nconst rgba = require('color-normalize')\nconst getBounds = require('array-bounds')\nconst extend = require('object-assign')\nconst glslify = require('glslify')\nconst pick = require('pick-by-alias')\nconst flatten = require('flatten-vertex-data')\nconst triangulate = require('earcut')\nconst normalize = require('array-normalize')\nconst { float32, fract32 } = require('to-float32')\nconst WeakMap = require('es6-weak-map')\nconst parseRect = require('parse-rect')\nconst findIndex = require('array-find-index');\n\n\nmodule.exports = Line2D\n\n\n/** @constructor */\nfunction Line2D (regl, options) {\n\tif (!(this instanceof Line2D)) return new Line2D(regl, options)\n\n\tif (typeof regl === 'function') {\n\t\tif (!options) options = {}\n\t\toptions.regl = regl\n\t}\n\telse {\n\t\toptions = regl\n\t}\n\tif (options.length) options.positions = options\n\tregl = options.regl\n\n\tif (!regl.hasExtension('ANGLE_instanced_arrays')) {\n\t\tthrow Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n\t}\n\n\t// persistent variables\n\tthis.gl = regl._gl\n\tthis.regl = regl\n\n\t// list of options for lines\n\tthis.passes = []\n\n\t// cached shaders instance\n\tthis.shaders = Line2D.shaders.has(regl) ? Line2D.shaders.get(regl) : Line2D.shaders.set(regl, Line2D.createShaders(regl)).get(regl)\n\n\n\t// init defaults\n\tthis.update(options)\n}\n\n\nLine2D.dashMult = 2\nLine2D.maxPatternLength = 256\nLine2D.precisionThreshold = 3e6\nLine2D.maxPoints = 1e4\nLine2D.maxLines = 2048\n\n\n// cache of created draw calls per-regl instance\nLine2D.shaders = new WeakMap()\n\n\n// create static shaders once\nLine2D.createShaders = function (regl) {\n\tlet offsetBuffer = regl.buffer({\n\t\tusage: 'static',\n\t\ttype: 'float',\n\t\tdata: [0,1, 0,0, 1,1, 1,0]\n\t})\n\n\tlet shaderOptions = {\n\t\tprimitive: 'triangle strip',\n\t\tinstances: regl.prop('count'),\n\t\tcount: 4,\n\t\toffset: 0,\n\n\t\tuniforms: {\n\t\t\tmiterMode: (ctx, prop) => prop.join === 'round' ? 2 : 1,\n\t\t\tmiterLimit: regl.prop('miterLimit'),\n\t\t\tscale: regl.prop('scale'),\n\t\t\tscaleFract: regl.prop('scaleFract'),\n\t\t\ttranslateFract: regl.prop('translateFract'),\n\t\t\ttranslate: regl.prop('translate'),\n\t\t\tthickness: regl.prop('thickness'),\n\t\t\tdashTexture: regl.prop('dashTexture'),\n\t\t\topacity: regl.prop('opacity'),\n\t\t\tpixelRatio: regl.context('pixelRatio'),\n\t\t\tid: regl.prop('id'),\n\t\t\tdashLength: regl.prop('dashLength'),\n\t\t\tviewport: (c, p) => [p.viewport.x, p.viewport.y, c.viewportWidth, c.viewportHeight],\n\t\t\tdepth: regl.prop('depth')\n\t\t},\n\n\t\tblend: {\n\t\t\tenable: true,\n\t\t\tcolor: [0,0,0,0],\n\t\t\tequation: {\n\t\t\t\trgb: 'add',\n\t\t\t\talpha: 'add'\n\t\t\t},\n\t\t\tfunc: {\n\t\t\t\tsrcRGB: 'src alpha',\n\t\t\t\tdstRGB: 'one minus src alpha',\n\t\t\t\tsrcAlpha: 'one minus dst alpha',\n\t\t\t\tdstAlpha: 'one'\n\t\t\t}\n\t\t},\n\t\tdepth: {\n\t\t\tenable: (c, p) => {\n\t\t\t\treturn !p.overlay\n\t\t\t}\n\t\t},\n\t\tstencil: {enable: false},\n\t\tscissor: {\n\t\t\tenable: true,\n\t\t\tbox: regl.prop('viewport')\n\t\t},\n\t\tviewport: regl.prop('viewport')\n\t}\n\n\n\t// simplified rectangular line shader\n\tlet drawRectLine = regl(extend({\n\t\tvert: glslify('./rect-vert.glsl'),\n\t\tfrag: glslify('./rect-frag.glsl'),\n\n\t\tattributes: {\n\t\t\t// if point is at the end of segment\n\t\t\tlineEnd: {\n\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\tdivisor: 0,\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 0\n\t\t\t},\n\t\t\t// if point is at the top of segment\n\t\t\tlineTop: {\n\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\tdivisor: 0,\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 4\n\t\t\t},\n\t\t\t// beginning of line coordinate\n\t\t\taCoord: {\n\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\t// end of line coordinate\n\t\t\tbCoord: {\n\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 16,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\taCoordFract: {\n\t\t\t\tbuffer: regl.prop('positionFractBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\tbCoordFract: {\n\t\t\t\tbuffer: regl.prop('positionFractBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 16,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\tcolor: {\n\t\t\t\tbuffer: regl.prop('colorBuffer'),\n\t\t\t\tstride: 4,\n\t\t\t\toffset: 0,\n\t\t\t\tdivisor: 1\n\t\t\t}\n\t\t}\n\t}, shaderOptions))\n\n\t// create regl draw\n\tlet drawMiterLine\n\n\ttry {\n\t\tdrawMiterLine = regl(extend({\n\t\t\t// culling removes polygon creasing\n\t\t\tcull: {\n\t\t\t\tenable: true,\n\t\t\t\tface: 'back'\n\t\t\t},\n\n\t\t\tvert: glslify('./miter-vert.glsl'),\n\t\t\tfrag: glslify('./miter-frag.glsl'),\n\n\t\t\tattributes: {\n\t\t\t\t// is line end\n\t\t\t\tlineEnd: {\n\t\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\t\tdivisor: 0,\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 0\n\t\t\t\t},\n\t\t\t\t// is line top\n\t\t\t\tlineTop: {\n\t\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\t\tdivisor: 0,\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 4\n\t\t\t\t},\n\t\t\t\t// left color\n\t\t\t\taColor: {\n\t\t\t\t\tbuffer: regl.prop('colorBuffer'),\n\t\t\t\t\tstride: 4,\n\t\t\t\t\toffset: 0,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\t// right color\n\t\t\t\tbColor: {\n\t\t\t\t\tbuffer: regl.prop('colorBuffer'),\n\t\t\t\t\tstride: 4,\n\t\t\t\t\toffset: 4,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\tprevCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 0,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\taCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 8,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\tbCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 16,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\tnextCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 24,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t}\n\t\t\t}\n\t\t}, shaderOptions))\n\t} catch (e) {\n\t\t// IE/bad Webkit fallback\n\t\tdrawMiterLine = drawRectLine\n\t}\n\n\t// fill shader\n\tlet drawFill = regl({\n\t\tprimitive: 'triangle',\n\t\telements: (ctx, prop) => prop.triangles,\n\t\toffset: 0,\n\n\t\tvert: glslify('./fill-vert.glsl'),\n\t\tfrag: glslify('./fill-frag.glsl'),\n\n\t\tuniforms: {\n\t\t\tscale: regl.prop('scale'),\n\t\t\tcolor: regl.prop('fill'),\n\t\t\tscaleFract: regl.prop('scaleFract'),\n\t\t\ttranslateFract: regl.prop('translateFract'),\n\t\t\ttranslate: regl.prop('translate'),\n\t\t\topacity: regl.prop('opacity'),\n\t\t\tpixelRatio: regl.context('pixelRatio'),\n\t\t\tid: regl.prop('id'),\n\t\t\tviewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]\n\t\t},\n\n\t\tattributes: {\n\t\t\tposition: {\n\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8\n\t\t\t},\n\t\t\tpositionFract: {\n\t\t\t\tbuffer: regl.prop('positionFractBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8\n\t\t\t}\n\t\t},\n\n\t\tblend: shaderOptions.blend,\n\n\t\tdepth: { enable: false },\n\t\tscissor: shaderOptions.scissor,\n\t\tstencil: shaderOptions.stencil,\n\t\tviewport: shaderOptions.viewport\n\t})\n\n\treturn {\n\t\tfill: drawFill, rect: drawRectLine, miter: drawMiterLine\n\t}\n}\n\n\n// used to for new lines instances\nLine2D.defaults = {\n\tdashes: null,\n\tjoin: 'miter',\n\tmiterLimit: 1,\n\tthickness: 10,\n\tcap: 'square',\n\tcolor: 'black',\n\topacity: 1,\n\toverlay: false,\n\tviewport: null,\n\trange: null,\n\tclose: false,\n\tfill: null\n}\n\n\nLine2D.prototype.render = function (...args) {\n\tif (args.length) {\n\t\tthis.update(...args)\n\t}\n\n\tthis.draw()\n}\n\n\nLine2D.prototype.draw = function (...args) {\n\t// render multiple polylines via regl batch\n\t(args.length ? args : this.passes).forEach((s, i) => {\n\t\t// render array pass as a list of passes\n\t\tif (s && Array.isArray(s)) return this.draw(...s)\n\n\t\tif (typeof s === 'number') s = this.passes[s]\n\n\t\tif (!(s && s.count > 1 && s.opacity)) return\n\n\t\tthis.regl._refresh()\n\n\t\tif (s.fill && s.triangles && s.triangles.length > 2) {\n\t\t\tthis.shaders.fill(s)\n\t\t}\n\n\t\tif (!s.thickness) return\n\n\t\t// high scale is only available for rect mode with precision\n\t\tif (s.scale[0] * s.viewport.width > Line2D.precisionThreshold || s.scale[1] * s.viewport.height > Line2D.precisionThreshold) {\n\t\t\tthis.shaders.rect(s)\n\t\t}\n\n\t\t// thin this.passes or too many points are rendered as simplified rect shader\n\t\telse if (s.join === 'rect' || (!s.join && (s.thickness <= 2 || s.count >= Line2D.maxPoints))) {\n\t\t\tthis.shaders.rect(s)\n\t\t}\n\t\telse {\n\t\t\tthis.shaders.miter(s)\n\t\t}\n\t})\n\n\treturn this\n}\n\nLine2D.prototype.update = function (options) {\n\tif (!options) return\n\n\tif (options.length != null) {\n\t\tif (typeof options[0] === 'number') options = [{positions: options}]\n\t}\n\n\t// make options a batch\n\telse if (!Array.isArray(options)) options = [options]\n\n\tlet { regl, gl } = this\n\n\t// process per-line settings\n\toptions.forEach((o, i) => {\n\t\tlet state = this.passes[i]\n\n\t\tif (o === undefined) return\n\n\t\t// null-argument removes pass\n\t\tif (o === null) {\n\t\t\tthis.passes[i] = null\n\t\t\treturn\n\t\t}\n\n\t\tif (typeof o[0] === 'number') o = {positions: o}\n\n\t\t// handle aliases\n\t\to = pick(o, {\n\t\t\tpositions: 'positions points data coords',\n\t\t\tthickness: 'thickness lineWidth lineWidths line-width linewidth width stroke-width strokewidth strokeWidth',\n\t\t\tjoin: 'lineJoin linejoin join type mode',\n\t\t\tmiterLimit: 'miterlimit miterLimit',\n\t\t\tdashes: 'dash dashes dasharray dash-array dashArray',\n\t\t\tcolor: 'color colour stroke colors colours stroke-color strokeColor',\n\t\t\tfill: 'fill fill-color fillColor',\n\t\t\topacity: 'alpha opacity',\n\t\t\toverlay: 'overlay crease overlap intersect',\n\t\t\tclose: 'closed close closed-path closePath',\n\t\t\trange: 'range dataBox',\n\t\t\tviewport: 'viewport viewBox',\n\t\t\thole: 'holes hole hollow',\n\t\t\tsplitNull: 'splitNull'\n\t\t})\n\n\t\t// init state\n\t\tif (!state) {\n\t\t\tthis.passes[i] = state = {\n\t\t\t\tid: i,\n\t\t\t\tscale: null,\n\t\t\t\tscaleFract: null,\n\t\t\t\ttranslate: null,\n\t\t\t\ttranslateFract: null,\n\t\t\t\tcount: 0,\n\t\t\t\thole: [],\n\t\t\t\tdepth: 0,\n\n\t\t\t\tdashLength: 1,\n\t\t\t\tdashTexture: regl.texture({\n\t\t\t\t\tchannels: 1,\n\t\t\t\t\tdata: new Uint8Array([255]),\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1,\n\t\t\t\t\tmag: 'linear',\n\t\t\t\t\tmin: 'linear'\n\t\t\t\t}),\n\n\t\t\t\tcolorBuffer: regl.buffer({\n\t\t\t\t\tusage: 'dynamic',\n\t\t\t\t\ttype: 'uint8',\n\t\t\t\t\tdata: new Uint8Array()\n\t\t\t\t}),\n\t\t\t\tpositionBuffer: regl.buffer({\n\t\t\t\t\tusage: 'dynamic',\n\t\t\t\t\ttype: 'float',\n\t\t\t\t\tdata: new Uint8Array()\n\t\t\t\t}),\n\t\t\t\tpositionFractBuffer: regl.buffer({\n\t\t\t\t\tusage: 'dynamic',\n\t\t\t\t\ttype: 'float',\n\t\t\t\t\tdata: new Uint8Array()\n\t\t\t\t})\n\t\t\t}\n\n\t\t\to = extend({}, Line2D.defaults, o)\n\t\t}\n\t\tif (o.thickness != null) state.thickness = parseFloat(o.thickness)\n\t\tif (o.opacity != null) state.opacity = parseFloat(o.opacity)\n\t\tif (o.miterLimit != null) state.miterLimit = parseFloat(o.miterLimit)\n\t\tif (o.overlay != null) {\n\t\t\tstate.overlay = !!o.overlay\n\t\t\tif (i < Line2D.maxLines) {\n\t\t\t\tstate.depth = 2 * (Line2D.maxLines - 1 - i % Line2D.maxLines) / Line2D.maxLines - 1.;\n\t\t\t}\n\t\t}\n\t\tif (o.join != null) state.join = o.join\n\t\tif (o.hole != null) state.hole = o.hole\n\t\tif (o.fill != null) state.fill = !o.fill ? null : rgba(o.fill, 'uint8')\n\t\tif (o.viewport != null) state.viewport = parseRect(o.viewport)\n\n\t\tif (!state.viewport) {\n\t\t\tstate.viewport = parseRect([\n\t\t\t\tgl.drawingBufferWidth,\n\t\t\t\tgl.drawingBufferHeight\n\t\t\t])\n\t\t}\n\n\t\tif (o.close != null) state.close = o.close\n\n\t\t// reset positions\n\t\tif (o.positions === null) o.positions = []\n\t\tif (o.positions) {\n\t\t\tlet positions, count\n\n\t\t\t// if positions are an object with x/y\n\t\t\tif (o.positions.x && o.positions.y) {\n\t\t\t\tlet xPos = o.positions.x\n\t\t\t\tlet yPos = o.positions.y\n\t\t\t\tcount = state.count = Math.max(\n\t\t\t\t\txPos.length,\n\t\t\t\t\tyPos.length\n\t\t\t\t)\n\t\t\t\tpositions = new Float64Array(count * 2)\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tpositions[i * 2] = xPos[i]\n\t\t\t\t\tpositions[i * 2 + 1] = yPos[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpositions = flatten(o.positions, 'float64')\n\t\t\t\tcount = state.count = Math.floor(positions.length / 2)\n\t\t\t}\n\n\t\t\tlet bounds = state.bounds = getBounds(positions, 2)\n\n\t\t\t// create fill positions\n\t\t\t// FIXME: fill positions can be set only along with positions\n\t\t\tif (state.fill) {\n\t\t\t\tlet pos = []\n\n\t\t\t\t// filter bad vertices and remap triangles to ensure shape\n\t\t\t\tlet ids = {}\n\t\t\t\tlet lastId = 0\n\n\t\t\t\tfor (let i = 0, ptr = 0, l = state.count; i < l; i++) {\n\t\t\t\t\tlet x = positions[i*2]\n\t\t\t\t\tlet y = positions[i*2 + 1]\n\t\t\t\t\tif (isNaN(x) || isNaN(y) || x == null || y == null) {\n\t\t\t\t\t\tx = positions[lastId*2]\n\t\t\t\t\t\ty = positions[lastId*2 + 1]\n\t\t\t\t\t\tids[i] = lastId\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlastId = i\n\t\t\t\t\t}\n\t\t\t\t\tpos[ptr++] = x\n\t\t\t\t\tpos[ptr++] = y\n\t\t\t\t}\n\n\t\t\t\t// split the input into multiple polygon at Null/NaN\n\t\t\t\tif(o.splitNull){\n\t\t\t\t\t// use \"ids\" to track the boundary of segment\n\t\t\t\t\t// the keys in \"ids\" is the end boundary of a segment, or split point\n\n\t\t\t\t\t// make sure there is at least one segment\n\t\t\t\t\tif(!(state.count-1 in ids)) ids[state.count] = state.count-1\n\n\t\t\t\t\tlet splits = Object.keys(ids).map(Number).sort((a, b) => a - b)\n\n\t\t\t\t\tlet split_triangles = []\n\t\t\t\t\tlet base = 0\n\n\t\t\t\t\t// do not split holes\n\t\t\t\t\tlet hole_base = state.hole != null ? state.hole[0] : null\n\t\t\t\t\tif(hole_base != null){\n\t\t\t\t\t\tlet last_id = findIndex(splits, (e)=>e>=hole_base)\n\t\t\t\t\t\tsplits = splits.slice(0,last_id)\n\t\t\t\t\t\tsplits.push(hole_base)\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < splits.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// create temporary pos array with only one segment and all the holes\n\t\t\t\t\t\tlet seg_pos = pos.slice(base*2, splits[i]*2).concat(\n\t\t\t\t\t\t\thole_base ? pos.slice(hole_base*2) : []\n\t\t\t\t\t\t)\n\t\t\t\t\t\tlet hole = (state.hole || []).map((e) => e-hole_base+(splits[i]-base) )\n\t\t\t\t\t\tlet triangles = triangulate(seg_pos, hole)\n\t\t\t\t\t\t// map triangle index back to the original pos buffer\n\t\t\t\t\t\ttriangles = triangles.map(\n\t\t\t\t\t\t\t(e)=> e + base + ((e + base < splits[i]) ? 0 : hole_base - splits[i])\n\t\t\t\t\t\t)\n\t\t\t\t\t\tsplit_triangles.push(...triangles)\n\n\t\t\t\t\t\t// skip split point\n\t\t\t\t\t\tbase = splits[i] + 1\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0, l = split_triangles.length; i < l; i++) {\n\t\t\t\t\t\tif (ids[split_triangles[i]] != null) split_triangles[i] = ids[split_triangles[i]]\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.triangles = split_triangles\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// treat the wholw input as a single polygon\n\t\t\t\t\tlet triangles = triangulate(pos, state.hole || [])\n\n\t\t\t\t\tfor (let i = 0, l = triangles.length; i < l; i++) {\n\t\t\t\t\t\tif (ids[triangles[i]] != null) triangles[i] = ids[triangles[i]]\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.triangles = triangles\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update position buffers\n\t\t\tlet npos = new Float64Array(positions)\n\t\t\tnormalize(npos, 2, bounds)\n\n\t\t\tlet positionData = new Float64Array(count * 2 + 6)\n\n\t\t\t// rotate first segment join\n\t\t\tif (state.close) {\n\t\t\t\tif (positions[0] === positions[count*2 - 2] &&\n\t\t\t\t\tpositions[1] === positions[count*2 - 1]) {\n\t\t\t\t\tpositionData[0] = npos[count*2 - 4]\n\t\t\t\t\tpositionData[1] = npos[count*2 - 3]\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpositionData[0] = npos[count*2 - 2]\n\t\t\t\t\tpositionData[1] = npos[count*2 - 1]\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpositionData[0] = npos[0]\n\t\t\t\tpositionData[1] = npos[1]\n\t\t\t}\n\n\t\t\tpositionData.set(npos, 2)\n\n\t\t\t// add last segment\n\t\t\tif (state.close) {\n\t\t\t\t// ignore coinciding start/end\n\t\t\t\tif (positions[0] === positions[count*2 - 2] &&\n\t\t\t\t\tpositions[1] === positions[count*2 - 1]) {\n\t\t\t\t\tpositionData[count*2 + 2] = npos[2]\n\t\t\t\t\tpositionData[count*2 + 3] = npos[3]\n\t\t\t\t\tstate.count -= 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpositionData[count*2 + 2] = npos[0]\n\t\t\t\t\tpositionData[count*2 + 3] = npos[1]\n\t\t\t\t\tpositionData[count*2 + 4] = npos[2]\n\t\t\t\t\tpositionData[count*2 + 5] = npos[3]\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add stub\n\t\t\telse {\n\t\t\t\tpositionData[count*2 + 2] = npos[count*2 - 2]\n\t\t\t\tpositionData[count*2 + 3] = npos[count*2 - 1]\n\t\t\t\tpositionData[count*2 + 4] = npos[count*2 - 2]\n\t\t\t\tpositionData[count*2 + 5] = npos[count*2 - 1]\n\t\t\t}\n\n\t\t\tvar float_data = float32(positionData)\n\t\t\tstate.positionBuffer(float_data)\n\t\t\tvar frac_data = fract32(positionData, float_data)\n\t\t\tstate.positionFractBuffer(frac_data)\n\t\t}\n\n\t\tif (o.range) {\n\t\t\tstate.range = o.range\n\t\t} else if (!state.range) {\n\t\t\tstate.range = state.bounds\n\t\t}\n\n\t\tif ((o.range || o.positions) && state.count) {\n\t\t\tlet bounds = state.bounds\n\n\t\t\tlet boundsW = bounds[2] - bounds[0],\n\t\t\t\tboundsH = bounds[3] - bounds[1]\n\n\t\t\tlet rangeW = state.range[2] - state.range[0],\n\t\t\t\trangeH = state.range[3] - state.range[1]\n\n\t\t\tstate.scale = [\n\t\t\t\tboundsW / rangeW,\n\t\t\t\tboundsH / rangeH\n\t\t\t]\n\t\t\tstate.translate = [\n\t\t\t\t-state.range[0] / rangeW + bounds[0] / rangeW || 0,\n\t\t\t\t-state.range[1] / rangeH + bounds[1] / rangeH || 0\n\t\t\t]\n\n\t\t\tstate.scaleFract = fract32(state.scale)\n\t\t\tstate.translateFract = fract32(state.translate)\n\t\t}\n\n\t\tif (o.dashes) {\n\t\t\tlet dashLength = 0., dashData\n\n\t\t\tif (!o.dashes || o.dashes.length < 2) {\n\t\t\t\tdashLength = 1.\n\t\t\t\tdashData = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255])\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tdashLength = 0.;\n\t\t\t\tfor(let i = 0; i < o.dashes.length; ++i) {\n\t\t\t\t\tdashLength += o.dashes[i]\n\t\t\t\t}\n\t\t\t\tdashData = new Uint8Array(dashLength * Line2D.dashMult)\n\t\t\t\tlet ptr = 0\n\t\t\t\tlet fillColor = 255\n\n\t\t\t\t// repeat texture two times to provide smooth 0-step\n\t\t\t\tfor (let k = 0; k < 2; k++) {\n\t\t\t\t\tfor(let i = 0; i < o.dashes.length; ++i) {\n\t\t\t\t\t\tfor(let j = 0, l = o.dashes[i] * Line2D.dashMult * .5; j < l; ++j) {\n\t\t\t\t\t\t\tdashData[ptr++] = fillColor\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfillColor ^= 255\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.dashLength = dashLength\n\t\t\tstate.dashTexture({\n\t\t\t\tchannels: 1,\n\t\t\t\tdata: dashData,\n\t\t\t\twidth: dashData.length,\n\t\t\t\theight: 1,\n\t\t\t\tmag: 'linear',\n\t\t\t\tmin: 'linear'\n\t\t\t}, 0, 0)\n\t\t}\n\n\t\tif (o.color) {\n\t\t\tlet count = state.count\n\t\t\tlet colors = o.color\n\n\t\t\tif (!colors) colors = 'transparent'\n\n\t\t\tlet colorData = new Uint8Array(count * 4 + 4)\n\n\t\t\t// convert colors to typed arrays\n\t\t\tif (!Array.isArray(colors) || typeof colors[0] === 'number') {\n\t\t\t\tlet c = rgba(colors, 'uint8')\n\n\t\t\t\tfor (let i = 0; i < count + 1; i++) {\n\t\t\t\t\tcolorData.set(c, i * 4)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tlet c = rgba(colors[i], 'uint8')\n\t\t\t\t\tcolorData.set(c, i * 4)\n\t\t\t\t}\n\t\t\t\tcolorData.set(rgba(colors[0], 'uint8'), count * 4)\n\t\t\t}\n\n\t\t\tstate.colorBuffer({\n\t\t\t\tusage: 'dynamic',\n\t\t\t\ttype: 'uint8',\n\t\t\t\tdata: colorData\n\t\t\t})\n\t\t}\n\t})\n\n\t// remove unmentioned passes\n\tif (options.length < this.passes.length) {\n\t\tfor (let i = options.length; i < this.passes.length; i++) {\n\t\t\tlet pass = this.passes[i]\n\t\t\tif (!pass) continue\n\t\t\tpass.colorBuffer.destroy()\n\t\t\tpass.positionBuffer.destroy()\n\t\t\tpass.dashTexture.destroy()\n\t\t}\n\t\tthis.passes.length = options.length\n\t}\n\n\t// remove null items\n\tlet passes = []\n\tfor (let i = 0; i < this.passes.length; i++) {\n\t\tif (this.passes[i] !== null) passes.push(this.passes[i])\n\t}\n\tthis.passes = passes\n\n\treturn this\n}\n\nLine2D.prototype.destroy = function () {\n\tthis.passes.forEach(pass => {\n\t\tpass.colorBuffer.destroy()\n\t\tpass.positionBuffer.destroy()\n\t\tpass.dashTexture.destroy()\n\t})\n\n\tthis.passes.length = 0\n\n\treturn this\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}